<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Erics">
        <link rel="canonical" href="https://docs.pythoneers.cn/python-web/django.html">
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Django - PYTHONEERS</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <link href="../css/nav.css" rel="stylesheet">
        <link href="../css/public.css" rel="stylesheet">
    

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    <script data-ad-client="ca-pub-6937898095875663" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!--    <script async src="../js/somelib.js"></script>-->
 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="..">PYTHONEERS</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Python <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../python/python3.html">基础到进阶</a>
</li>
                                    
<li >
    <a href="../python/module.html">内置模块与第三方模块</a>
</li>
                                    
<li >
    <a href="../python/algorithm.html">数据结构与算法</a>
</li>
                                    
<li >
    <a href="../python/design-pattern.html">设计模式</a>
</li>
                                    
<li >
    <a href="../python/leetcode.html">Leetcode</a>
</li>
                                    
<li >
    <a href="../python/offer.html">剑指Offer</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Python Web <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li class="active">
    <a href="django.html">Django</a>
</li>
                                    
<li >
    <a href="drf.html">Django Rest Framework</a>
</li>
                                    
<li >
    <a href="flask.html">Flask</a>
</li>
                                    
<li >
    <a href="mysql.html">MySQL</a>
</li>
                                    
<li >
    <a href="redis.html">Redis</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Python GUI <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../gui/pyqt5.html">PyQt5</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">网络爬虫 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../web-crawler/scrapy.html">Scrapy</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">数据分析 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../data-analysis/numpy.html">NumPy</a>
</li>
                                    
<li >
    <a href="../data-analysis/pandas.html">Pandas</a>
</li>
                                    
<li >
    <a href="../data-analysis/matplotlib.html">Matplotlib</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">计算机视觉 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../computer-vision/opencv.html">OpenCV</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">机器学习 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../machine-learning/quantitative-trading.html">机器学习与量化交易</a>
</li>
                                </ul>
                            </li>
                            <li >
                                <a href="../deep-learning/deep-learning.html">深度学习</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                            <li >
                                <a rel="next" href="../python/offer.html">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="drf.html">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#python-web">Python Web框架</a></li>
            <li><a href="#1-http">1. http协议</a></li>
            <li><a href="#2-socket">2. socket是什么</a></li>
            <li><a href="#3-socket">3. socket服务端</a></li>
            <li><a href="#4-web">4. web框架的分类</a></li>
            <li><a href="#5-pythonweb">5. Python三大web框架的比较</a></li>
            <li><a href="#6-web">6. 静态web框架</a></li>
            <li><a href="#7-web">7. 动态web框架</a></li>
        <li class="main "><a href="#django">Django初识</a></li>
            <li><a href="#1-django">1. Django的安装</a></li>
            <li><a href="#2-django">2. Django程序的创建与运行</a></li>
            <li><a href="#3-django">3. Django程序的目录</a></li>
            <li><a href="#4-django">4. Django模板路径的配置</a></li>
            <li><a href="#5-django">5. Django静态文件路径的配置</a></li>
            <li><a href="#6-django">6. Django额外配置</a></li>
            <li><a href="#7-httpresponserender">7.  HttpResponse函数与render函数</a></li>
            <li><a href="#8-getpost">8. GET和POST请求</a></li>
        <li class="main "><a href="#_1">简单用户登录案例</a></li>
            <li><a href="#1">1. 登录模板</a></li>
            <li><a href="#2">2. 登录逻辑</a></li>
            <li><a href="#3">3. 结论</a></li>
        <li class="main "><a href="#django_1">Django模板语法</a></li>
            <li><a href="#1_1">1. 取字符串的值</a></li>
            <li><a href="#2_1">2. 取列表的值</a></li>
            <li><a href="#3_1">3. 取字典的值</a></li>
            <li><a href="#4">4. 取嵌套在列表中的字典的值</a></li>
            <li><a href="#5">5. 母板</a></li>
            <li><a href="#6-include">6. include</a></li>
            <li><a href="#7">7. 模板的内置函数</a></li>
            <li><a href="#8">8. 模板自定义函数</a></li>
            <li><a href="#9-simple_filtersimple_tag">9. simple_filter和simple_tag</a></li>
        <li class="main "><a href="#cookie">操作cookie</a></li>
            <li><a href="#1-cookie">1. 初识cookie</a></li>
            <li><a href="#2-cookie">2. 操作cookie的方式</a></li>
            <li><a href="#3-cookie">3. 设置cookie的签名</a></li>
            <li><a href="#4-cookie">4. 基于cookie的登录验证</a></li>
            <li><a href="#5-django_1">5. Django主流操作</a></li>
        <li class="main "><a href="#_2">项目的创建和目录文件的介绍</a></li>
            <li><a href="#1-django_1">1. 创建一个完整的Django项目</a></li>
            <li><a href="#2-django_1">2. Django主要相关目录文件介绍</a></li>
        <li class="main "><a href="#_3">路由系统</a></li>
            <li><a href="#1_2">1. 静态路由</a></li>
            <li><a href="#2_2">2. 动态路由</a></li>
            <li><a href="#3_2">3. 路由分发</a></li>
            <li><a href="#4_1">4. 反向生成路由</a></li>
        <li class="main "><a href="#orm">ORM操作</a></li>
            <li><a href="#1-orm">1. ORM的功能</a></li>
            <li><a href="#2_3">2. 数据库设置</a></li>
            <li><a href="#3-makemigrationsmigrate">3. makemigrations和migrate</a></li>
            <li><a href="#4-orm">4. ORM创建数据表</a></li>
            <li><a href="#5-ormcurd">5. ORM单表CURD</a></li>
            <li><a href="#6">6. 正向连表操作</a></li>
            <li><a href="#7_1">7. 反向连表操作</a></li>
            <li><a href="#8_1">8. 获取数据的三种方式</a></li>
        <li class="main "><a href="#cbv">CBV的使用</a></li>
            <li><a href="#1-cbv">1. CBV的引入</a></li>
            <li><a href="#2-cbv">2. CBV的应用</a></li>
            <li><a href="#3-dispatch">3. dispatch方法</a></li>
            <li><a href="#4-cbv">4. CBV中添加装饰器</a></li>
        <li class="main "><a href="#_4">内置分页</a></li>
            <li><a href="#1_3">1. 后台分页逻辑</a></li>
            <li><a href="#2_4">2. 前台分页展示</a></li>
        <li class="main "><a href="#_5">自定义分页</a></li>
            <li><a href="#1_4">1. 自定义分页效果</a></li>
            <li><a href="#2_5">2. 自定义分页的实现</a></li>
            <li><a href="#3_3">3. 分页插件</a></li>
        <li class="main "><a href="#xss">跨站脚本攻击XSS</a></li>
            <li><a href="#1-djangoxss">1. Django处理XSS攻击</a></li>
            <li><a href="#2_6">2. 前端标记字符串</a></li>
            <li><a href="#3_4">3. 后端标记字符串</a></li>
        <li class="main "><a href="#csrf">跨站请求伪造CSRF</a></li>
            <li><a href="#1_5">1. 基本应用</a></li>
            <li><a href="#2_7">2. 全站禁用</a></li>
            <li><a href="#3_5">3. 局部禁用</a></li>
            <li><a href="#4_2">4. 局部使用</a></li>
            <li><a href="#5-ajaxcsrf">5. AJAX携带CSRF提交数据</a></li>
        <li class="main "><a href="#session">Session基本使用</a></li>
            <li><a href="#1-session">1. Session简介</a></li>
            <li><a href="#2-session">2. 基于Session的用户登录</a></li>
            <li><a href="#3-session">3. Session的配置</a></li>
            <li><a href="#4-session">4. Session数据源配置</a></li>
        <li class="main "><a href="#wsgi">WSGI</a></li>
            <li><a href="#1-wsgi">1. WSGI</a></li>
            <li><a href="#2-django_2">2. Django请求的生命周期</a></li>
        <li class="main "><a href="#_6">中间件</a></li>
            <li><a href="#1_6">1. 中间件执行流程</a></li>
            <li><a href="#2_8">2. 中间件原理浅析</a></li>
            <li><a href="#3_6">3. 中间件的应用</a></li>
            <li><a href="#4_3">4. 中间件解决跨域问题</a></li>
        <li class="main "><a href="#form">Form组件</a></li>
            <li><a href="#1-form">1. Form组件的功能</a></li>
            <li><a href="#2_9">2. 数据校验</a></li>
            <li><a href="#3_7">3. 常用字段和参数</a></li>
            <li><a href="#4_4">4. 保留上次输入内容</a></li>
        <li class="main "><a href="#_7">信号</a></li>
            <li><a href="#1-django_2">1. Django信号使用场景</a></li>
            <li><a href="#2-django_3">2. Django内置信号</a></li>
            <li><a href="#3-django_1">3. Django信号简单示例</a></li>
        <li class="main "><a href="#api">API接口开发</a></li>
            <li><a href="#1_7">1. 模型的创建</a></li>
            <li><a href="#2_10">2. 路由系统的创建</a></li>
            <li><a href="#3_8">3. 添加数据的接口</a></li>
            <li><a href="#4_5">4. 获取所有数据的接口</a></li>
            <li><a href="#5_1">5. 获取单条数据的接口</a></li>
            <li><a href="#6_1">6. 更新数据的接口</a></li>
            <li><a href="#7_2">7. 删除数据的接口</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<p><span id="busuanzi_container_page_pv">阅读量：<span id="busuanzi_value_page_pv"></span>次</span>
<hr></p>
<p><img alt="" src="../img/django.jpeg" /></p>
<h4 id="python-web">Python Web框架</h4>
<hr>

<h5 id="1-http">1. http协议</h5>
<p>http协议是无状态，短连接的。客户端连接服务器，发送请求，服务器响应请求后断开连接。
<hr></p>
<h5 id="2-socket">2. socket是什么</h5>
<p>所有的网络请求都是基于socket，浏览器是socket客户端，网站是socket服务端。
<hr></p>
<h5 id="3-socket">3. socket服务端</h5>
<p>根据 url 的不同返回给用户不同的内容，使用路由系统，路由系统是url与函数的对应关系。返回给用户的内容本质是字符串，基本上返回的内容是动态的，所以需要使用到模板渲染。模板渲染实际上是把 html 充当模板，自己创造任意数据替换模板中的特殊字符，比如替换特殊字符为数据库中的数据。
<hr></p>
<h5 id="4-web">4. web框架的分类</h5>
<p>为了方便开发者开发 web 应用，web 框架应用而生。有的 web 框架帮助开发者构建好了 socket 服务端，有的web框架帮助开发者写好了模板渲染。总之，借助web框架可以减轻了开发者的工作量。<font>Flask 框架只有路由系统，没有 socket 服务端和模板引擎，socket 服务端使用是 Python 第三方模块 wsgiref，模板引擎使用的也是第三方模块 jinjia2 </font>。<font>Django 框架有路由系统、模板引擎，但是没有 socket 服务端，socket 服务端使用的是 Python 的第三方内置模块如 wsgiref，wsgiref 把请求交给 django 做处理</font>。另外，还有Tornado框架，<font>Tornado 框架包含socket服务端、路由系统、模板引擎</font>。可以将 web 框架这样分类，Django 框架和其它框架。因为 Django 框架提供了很多特殊的功能，如缓存、分布式。其它框架是轻量级的 web 框架。
<hr></p>
<h5 id="5-pythonweb">5. Python三大web框架的比较</h5>
<p>Django、Flask 和 Tornado 框架都有路由、视图和模板，但是 Tornado 的模板是自己写的，Flask 的模板不是自己写的，采用的是第三方组件 Jinjia2。Django 自带 ORM，其它两个框架中没有。<font>Django 中在写 SQL 的时候不应该再使用 pymysql，而应该使用 ORM</font>。其实 ORM 只是做了类和对象的映射，类对应表，对象对应数据行。Django 中把类和对象转换成SQL语句，但是 <font>本质上还是需要 pymysql 去连接数据库</font>。对于 Flask 框架，可以使用 pymysql，也可以使用 SqlAchemy，Tornado 也是一样的。对于 Django，一般使用的是 ORM，但也可以使用 pymysql，但是这不是主流。<font>对于非常复杂的 sql 语句，ORM 完成不了，只能写原生 SQL</font>。Django 中 ORM 也支持原生 sql，所以没必要使用 pymysql。
<hr></p>
<h5 id="6-web">6. 静态web框架</h5>
<p>使用 Python 可以写一个静态的web框架，可以处理用户访问静态资源的请求。请求头：</p>
<pre><code class="py">'''
GET / HTTP/1.1
Host: 127.0.0.1:8080
Connection: keep-alive
Upgrade-Insecure-Requests: 1\
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3
Accept-Encoding: gzip, deflate, 
Accept-Language: zh-CN,zh;q=0.9
'''
</code></pre>

<p>使用 socket 接收用户的请求，处理用户的请求：</p>
<pre><code class="python">def f1(request):
    '''
    处理用户请求：直接返回字节类型数据数据
    '''
    # 返回字节类型的数据b'f1'
    return b'f1'

def f2(request):
    '''
    处理用户请求：返回文件中的内容
    '''
    # 打开文件
    f = open('index.html', 'rb')
    # 读取文件内容到内存中，赋值给data变量
    data = f.read()
    # 关闭文件
    f.close()
    # 返回数据
    return data

# 存放路由和对应函数到列表中
routers = [
    ('/user', f1),
    ('/', f2)
]

def run():
&quot;&quot;&quot;
处理用户请求
&quot;&quot;&quot;
    # 实例化socket对象
    sock = socket.socket()
    # 绑定ip地址和端口
    sock.bind(('127.0.0.1', 8080))
    # 设置允许排队的连接数，socket允许的连接数时排队的连接数加上线程数量
    sock.listen(5)
    # 循环等待
    while True:
        # 获取连接对象和连接的来源
        conn, addr = sock.accept()
        # 接收数据
        data = conn.recv(8096)
        # 解析请求头，目的是获取请求头中的url，并根据url向服务端发送请求
        # 格式化为utf-8的字符串
        data = str(data, encoding='utf-8') 
        # 根据\r\n\r\n将字符串分割为请求头和主体部分
        headers, bodys = data.split('\r\n\r\n') 
        # 使用\r\n分割得到请求方法，请求的url等
        headers_list = headers.split('\r\n')
        # 以空字符分割请求头的第一行得到请求的方法、路由和协议
        methods, url, protocal = headers_list[0].split(' ')
        # 遍历routers列表，确定请求的路由，找到路由对应的函数名
        for item in routers:
            # 如果获取的请求头中url和我们服务端的路由对应
            if item[0] == url:
                # 就找到了对应的函数
                func_name = item[1]
                break
        # 如果函数名不为空
        if func_name:
            # 执行函数
            response = func_name(data)
        else:
            # 为空则返回'404'
            response = '404'    
        # 如果路由时/user
        if url == '/user':
             conn.send(b'user page')
         else:
         # 没有找到路由则返回404
            conn.send(b'404 is not found!')
            conn.send(b&quot;HTTP/1.1 200 OK\r\n\r\n&quot;)  # 响应头
            conn.send(b&quot;hello thanlon!&quot;)  # 相应体
         conn.close()
</code></pre>

<h5 id="7-web">7. 动态web框架</h5>
<p>使用 Python 可以写一个动态的web框架，可以处理用户访问动态资源的请求。使用 socket 接收用户的请求，将请求的内容做简单的处理然后返回给用户：</p>
<pre><code class="python">def f1(request):
    '''
    处理用户请求：将动态的时间加入到返回的内容中
    '''
    f = open('news.html', 'r', encoding='utf-8')
    data = f.read()
    f.close()
    import time
    ctime = time.time()
    data = data.replace('%', str(ctime))
    return bytes(data, encoding='utf-8')

# 同样的定义个路由，routers最好要全部大写
routers = [
    ('/user', f1),
]
def run():
    sock = socket.socket()
    sock.bind(('127.0.0.1', 8080))
    sock.listen(5)
    while True:
        conn, addr = sock.accept()
        data = conn.recv(8096)
        data = str(data, encoding='utf-8')
        headers, bodys = data.split('\r\n\r\n')
        headers_list = headers.split('\r\n')
        methods, url, protocal = headers_list[0].split(' ')
        func_name = None
        for item in routers:
            if item[0] == url:
                func_name = item[1]
                break
        if func_name:
            response = func_name(data)
        else:
            response = '404'
        conn.close()
</code></pre>

<p>下面这个例子同样是可以处理用户访问动态资源的请求，但是使用到了数据库：</p>
<pre><code class="python">def f1(request):
    # 创建连接
    conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='123456', db='test')
    # 创建游标
    cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)
    # 执行sql语句，并返回受影响的行数
    cursor.execute(&quot;select id,name,passwd from userinfo&quot;)
    # 获取表中的所有数据
    user_list = cursor.fetchall()
    # 关闭游标
    cursor.close()
    # 关闭连接
    conn.close()
    content_list = []
    for row in user_list:
        # 将每一行字段的值加上html标签组成字符串，然后放到列表中
        tp = '&lt;tr&gt;%s&lt;/tr&gt;&lt;tr&gt;%s&lt;/tr&gt;&lt;tr&gt;%s&lt;/tr&gt;' % (row['id'], row['name'], row['passwd'],)
        content_list.append(tp)
    # 将列表中元素拼接为大的字符串
    content = ''.join(content_list)
    # userlist.html是个模板
    f = open('userlist.html', 'r', encoding='utf-8')
    template = f.read()
    f.close()
    # 替换模板的值：将{{content}}替换为从数据库中读取到的内容
    data = template.replace('{{content}}', content)
    # 返回替换为数据库中的数据
    return bytes(data, encoding='utf-8')

# 定义访问的路由
routers = [
    ('/user', f1),
]

def run():
&quot;&quot;&quot;
run函数主要是获取用户连接，接收用户发送的数据请求，把用户的请求交给路由对应的函数处理
&quot;&quot;&quot;
    sock = socket.socket()
    sock.bind(('127.0.0.1', 8080))
    sock.listen(5)
    while True:
        conn, addr = sock.accept()
        data = conn.recv(8096)
        data = str(data, encoding='utf-8')
        headers, bodys = data.split('\r\n\r\n')
        headers_list = headers.split('\r\n')
        methods, url, protocal = headers_list[0].split(' ')
        func_name = None
        for item in routers:
            if item[0] == url:
                func_name = item[1]
                break
        if func_name:
            response = func_name(data)
        else:
            response = b'404'
        conn.send(response)
        conn.close()
</code></pre>

<hr>

<h4 id="django">Django初识</h4>
<hr>

<h5 id="1-django">1. Django的安装</h5>
<p>推荐使用 pip 方式安装：<strong><code>pip install django</code></strong>，推荐使用国内镜像源，如阿里的镜像源，指定阿里镜像源来安装 Django：</p>
<pre><code class="python">pip3 install django -i https://mirrors.aliyun.com/pypi/simple
</code></pre>

<hr>

<h5 id="2-django">2. Django程序的创建与运行</h5>
<p>创建 Django 程序只需要使用简单的命令：</p>
<pre><code class="python">django-admin startproject pro_name
</code></pre>

<p>pro_name 是 Django 程序的名字。Django 程序的运行需要使用：</p>
<pre><code class="python">python manager.py runserver 127.0.0.1:8080
</code></pre>

<p>如果不指定地址和端口，默认使用本地地址和 8000 端口。
<hr></p>
<h5 id="3-django">3. Django程序的目录</h5>
<p><kbd>manager.py</kbd>：对当前Django程序所有的操作可以基于 python manage.py runserver。</p>
<p><kbd>settings.py</kbd>：Django 配置文件</p>
<p><kbd>url.py</kbd>：路由系统</p>
<p><kbd>wsgi.py</kbd>：用于定义 Django 使用什么 socket 服务端，如是 wsgiref，还是 uwsgi。<font>wsgiref的性能是比较低的！</font>
<hr></p>
<h5 id="4-django">4. Django模板路径的配置</h5>
<p>Django 程序默认的模板名称是 <strong><code>templates</code></strong>，在项目名称目录下。模板名称需要与配置文件中TEMPLATES参数中配置的一样，
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200511172445720.png" />
<hr></p>
<h5 id="5-django">5. Django静态文件路径的配置</h5>
<p>可以在项目名称目录下创建静态文件目录，常用的静态文件存放的目录的名字是 <strong><code>static</code></strong>，创建之后还需要修改配置文件来指定这个静态文件目录。修改配置文件：</p>
<pre><code class="py"># Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/2.2/howto/static-files/
'''
只要是使用/static/的前缀，就会在这个目录(static目录)下找静态文件
'''
STATIC_URL = '/static/'
STATICFILES_DIRS = (
    os.path.join(BASE_DIR, 'static'),
)
</code></pre>

<hr>

<h5 id="6-django">6. Django额外配置</h5>
<p>需要再配置文件中将 <strong><code>django.middleware.csrf.CsrfViewMiddleware</code></strong>注释起来，</p>
<pre><code class="py">MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    # 'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
</code></pre>

<hr>

<h5 id="7-httpresponserender">7.  HttpResponse函数与render函数</h5>
<p>HttpResponse 函数是可以用来返回字符串，render 函数用来返回模板。返回字符串：</p>
<pre><code class="python">return HttpResponse('login!')
return HttpResponse('&lt; input type=&quot;text&quot;&gt;')
</code></pre>

<p>返回模板：</p>
<pre><code class="python">return render(request, 'xxx.html')
</code></pre>

<p>reder 函数本质上调用的就是 HttpResponse函数。
<hr></p>
<h5 id="8-getpost">8. GET和POST请求</h5>
<p>相同点：POST请求的时候，<kbd>request.GET.get( )</kbd> 和 <kbd>request.POST.get( )</kbd> 都可以从请求头的 url 中获取值；</p>
<p>不同点：GET请求的时候，只有 <kbd>request.GET.get()</kbd> 可以获取值。值从请求地址 <strong><code>/login/?page=1</code></strong> 中获取page的值1。
<hr></p>
<h4 id="_1">简单用户登录案例</h4>
<p>简单的例子：用户输入用户名和密码后登录系统，这里暂时不连接数据库。系统验证登录成功，直接跳转到百度的首页。登录失败，系统会将错误信息打印在页面上。
<hr></p>
<h5 id="1">1. 登录模板</h5>
<p>模板中需要写个简单的登录表单，如下面的：</p>
<pre><code>&lt;form action=&quot;/login/&quot; method=&quot;POST&quot; name=&quot;loginForm&quot;&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;name&quot;&gt;用户名&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;
    &lt;/div&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;&quot;&gt;密码&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; name=&quot;pwd&quot; placeholder=&quot;请输入密码&quot;&gt;
        &lt;div style=&quot;color: red;font-weight: bold&quot;&gt;{{ msg }}&lt;/div&gt;
    &lt;/div&gt;
    &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot; onclick=&quot;return checkForm()&quot;&gt;登录&lt;/button&gt;
&lt;/form&gt;
</code></pre>

<p>模板中的 <strong><code>{{ msg }}</code></strong>
<hr></p>
<h5 id="2">2. 登录逻辑</h5>
<pre><code class="python">from django.urls import path
from django.shortcuts import HttpResponse, render, redirect

def login(request):  #
    '''
    处理用户请求，返回相响应结果
    :param request:用户请求的相关信息（不是字节，是对象）
    :return:
    '''
    if request.method == 'GET':
        return render(request, 'login.html')  # 本质上是调用HttpResponse，自动找到login.html文件，读取内容并返回给用户
    else:
        # print(request.POST)  # 用户POST提交的数据（请求体）&lt;QueryDict: {'name': ['thanlon'], 'pwd': ['123']}&gt;
        # user = request.POST['username']#直接索引，如果没有username会报错
        username = request.POST.get('username')  # 如果没有username不会报错，返回None
        pwd = request.POST.get('pwd')  # 如果没有username不会报错，返回None
        if username == 'thanlon' and pwd == '123456':
            return redirect('https://www.blueflags.cn')
        else:
            return render(request, 'login.html', {'msg': '用户名或密码错误！'})  # django内部做模板渲染

urlpatterns = [
    # path('admin/', admin.site.urls),
    path('login/', login),
]
</code></pre>

<hr>

<h5 id="3">3. 结论</h5>
<p>用户名和密码输入正确后，则登录成功跳转百度首页。否则，登录失败系统会将错误信息放到登录模板，然后传给用户。表现上是刷新表单界面，显示提示信息：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200511175759701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" />
<hr></p>
<h4 id="django_1">Django模板语法</h4>
<hr>

<h5 id="1_1">1. 取字符串的值</h5>
<p>返回模板的时候，加上传入的字符串：</p>
<pre><code class="py">def index(request):
    return render(request, 'index/index.html', {'username': 'thanlon'})
</code></pre>

<p>模板中解析传入的字符串：</p>
<pre><code class="html">{{ username }}
</code></pre>

<hr>

<h5 id="2_1">2. 取列表的值</h5>
<p>返回模板的时候，加上传入列表：</p>
<pre><code class="py">def index(request):
    return render(request, 'index/index.html', {'username': ['thanlon','Kiku']})
</code></pre>

<p>模板中解析传入的列表，直接通过索引取：</p>
<pre><code class="html">{{ username.0 }}
</code></pre>

<p>通过循环遍历：</p>
<pre><code class="html">{% for item in username %}
    {{ item }}
{% endfor %}
</code></pre>

<hr>

<h5 id="3_1">3. 取字典的值</h5>
<p>返回模板的时候，加上传入字典：</p>
<pre><code class="py">def index(request):
    return render(request, 'index/index.html', {
        'user_dict': {'name': 'thanlon', 'age': 23}
    })
</code></pre>

<p>模板中解析传入的字典：</p>
<pre><code class="html">{{ user_dict.name }}
{{ user_dict.age }}
</code></pre>

<hr>

<h5 id="4">4. 取嵌套在列表中的字典的值</h5>
<p>返回模板的时候，加上传入嵌套在列表中的字典：</p>
<pre><code class="python">def index(request):
    return render(request, 'index/index.html', {
        'user_list_dict': [
            {'id': 1, 'name': 'thanlon'},
            {'id': 2, 'name': 'kuku'},
        ]
    })
</code></pre>

<p>模板中解析传入的嵌套在列表中的字典，通过索引取值：</p>
<pre><code class="python">{{ user_list_dict.0.id}}        
{{ user_list_dict.0.name}}
{{ user_list_dict.1.id}}        
{{ user_list_dict.0.name}}
</code></pre>

<p>模板中解析传入的嵌套在列表中的字典，通过通过循环取值：</p>
<pre><code class="python">{% for row in user_list_dict %}
    {{ row.id }}
    {{ row.name }}
{% endfor %}
</code></pre>

<hr>

<h5 id="5">5. 母板</h5>
<p>把模板上公共的部分放到到母板中，可以减少代码量，如把模板头部的导航栏和尾部版权部分放入母板中。子板使用 <strong><code>{% extends "xxx.html" %}</code></strong> 来继承母板中的代码，extends 是 Django 内置的模板函数。但是，<font>一个子板只能继承一个母板 </font>。简而言之，母板是用来继承的。
<hr></p>
<h5 id="6-include">6. include</h5>
<p>include 也是 Django 内置的模板函数，使用的方式是：<strong><code>{% include "xxx.html" %}</code></strong>。include 是包含的意思，它的作用是把其它模板引入到自己的模板中。不限制 include 的使用次数，可以引入多个模板，但一般都是小的模板组件。模板渲染之前，会找到组件的内容替换掉 <strong><code>{% include "xxx.html" %}</code></strong> 合并后渲染。因此，如果组件中有需要传值部分，只需通过合并后的模板函数传值。
<hr></p>
<h5 id="7">7. 模板的内置函数</h5>
<p>模板的内置函数在模板中 <font>不需要加括号就可以自动执行</font>，</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{{ 'thanlon'|upper }}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200615174101704.png" />
<hr></p>
<h5 id="8">8. 模板自定义函数</h5>
<p>自定义模板函数需要以下操作：</p>
<p>( 1 ) 在应用目录下创建 templatetags 文件夹</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200615174851934.png" /></p>
<p>( 2 ) 在 templatetags 下创建一个 py 文件，文件名自定义：</p>
<pre><code class="python">from django import template

# 名称必须是register
register = template.Library()

@register.filter
def my_lower(value):
    return value.lower()
</code></pre>

<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200615174922172.png" /></p>
<p>( 3 ) 在模板中导入创建的 py 文件：</p>
<p><strong><code>index.html:</code></strong></p>
<pre><code class="html">{% load templates_func %}
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>( 4 ) 应用模板自定义的函数：</p>
<p><strong><code>index.html:</code></strong></p>
<pre><code class="html">{% load templates_func %}
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{{ 'thanlon'|my_lower }}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200615175844793.png" /></p>
<p>( 5 ) 在settings中配置当前app，否则django无法找到自定的模板函数。当然这里使用pycahrm软件直接就创建好了：</p>
<p><strong><code>settings.py:</code></strong></p>
<pre><code class="py">INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'app01.apps.App01Config',
]
</code></pre>

<p>这里读取的是 app.py 文件中的 App01Config 类的类变量：</p>
<p><strong><code>apps.py:</code></strong></p>
<pre><code class="py">from django.apps import AppConfig

class App01Config(AppConfig):
    name = 'app01'
</code></pre>

<hr>

<h5 id="9-simple_filtersimple_tag">9. simple_filter和simple_tag</h5>
<p>simple_filter <font>最多有两个参数</font>，格式是：<kbd>{{ 第一个参数|函数名称:"第二个参数" }}</kbd>，simple_filter 的使用：</p>
<p><strong><code>templates_func.py:</code></strong></p>
<pre><code class="py">from django import template

# 名称必须是register
register = template.Library()


@register.filter
def func(value, arg):
    return value + arg
</code></pre>

<p><strong><code>index.html:</code></strong></p>
<pre><code class="html">{% load templates_func %}
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{{ 1| func:1 }}
{{ 'Thanlon'| func:'!' }}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200615182122166.png" /></p>
<p>simple_tag 和 simple_filter 类似，但是 simple_tag 中设置函数的 <font>参数个数无限制</font>。使用格式：<kbd>{% 函数名 参数1 参数2 参数3 ... %}</kbd>，simple_tag 的使用：</p>
<p><strong><code>templates_func.py:</code></strong></p>
<pre><code class="py">from django import template

# 名称必须是register
register = template.Library()

@register.simple_tag
def func(v1, v2, v3):
    return v1 + v2 + v3
</code></pre>

<p><strong><code>index.html:</code></strong></p>
<pre><code class="html">{% load templates_func %}
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{% func 1 2 3 %}
{% func '1' '2' '3' %}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2020061518270876.png" /></p>
<p>simple_filter 与 simple_simple_tag 的区别是，simple_filter 可以 <font>作为提条件语句放到判断语句后面</font>，使用方式：
<strong><code>templates_func.py:</code></strong></p>
<pre><code class="py">from django import template

# 名称必须是register
register = template.Library()

@register.filter
def func(v):
    return v
</code></pre>

<p><strong><code>index.html:</code></strong></p>
<pre><code class="html">{% load templates_func %}
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{% if True|func %}
    &lt;h4&gt;Ture&lt;/h4&gt;
{% else %}
    &lt;h4&gt;False&lt;/h4&gt;
{% endif %}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<hr>

<h4 id="cookie">操作cookie</h4>
<hr>

<h5 id="1-cookie">1. 初识cookie</h5>
<p>cookie 是保存在浏览器端的特殊"键值对"，服务端可以向浏览器端写cookie。<font>客户端每次发送请求时需要携带本地 cookie，此时 cookie 放到请求头中</font>。<font>服务端回写 cookie 会放到响应头</font>中，<font>render 和 redirect 以及 HttpResponse 函数</font> 都可以在向服务端浏览器返回响应体的时候回写cookie。cookie的应用：<font>可以用于投票，也可以用于用户登录。</font>
<hr></p>
<h5 id="2-cookie">2. 操作cookie的方式</h5>
<p>(1) 设置超时时间有两种方式，下面是设置cookie的函数的源码：</p>
<pre><code class="py">def set_cookie(self, key, value='', max_age=None, expires=None, path='/',domain=None, secure=False, httponly=False, samesite=None):
    pass
</code></pre>

<p>第一种方式，使用 <strong><code>max_age</code></strong>。max_age=10 表示超时时间是10秒，<font>10秒过后不管客户端有没有操作，都会跳转到登录页面</font>。</p>
<pre><code class="py">def login(request):
    username = request.POST.get('username')
    pwd = request.POST.get('pwd')
    if request.method == 'POST':
        if username == 'thanlon' and pwd == '123456':
            obj = redirect('/classes/')
            # redirect对象的set_cookie方法来设置回传到浏览器的cookie
            obj.set_cookie('ticket', 'O2UikIFGGvHxcUQD7rIbgxedinIpEoMjStxoO579rgY8NeQM',max_age=10)
            return obj
    else:
        return render(request, 'login.html')
</code></pre>

<p>第二种方式，使用 expires：</p>
<pre><code class="py">def login(request):
    username = request.POST.get('username')
    pwd = request.POST.get('pwd')
    if request.method == 'POST':
        if username == 'thanlon' and pwd == '123456':
            obj = redirect('/classes/')
            from datetime import timedelta
            import datetime
            ct = datetime.datetime.utcnow()
            v = timedelta(seconds=10)  # 加10s
            value = ct + v
            obj.set_cookie('ticket', 'O2UikIFGGvHxcUQD7rIbgxedinIpEoMjStxoO579rgY8NeQM', expires=value)
            return obj
    else:
        return render(request, 'login.html')
</code></pre>

<p>PS：使用第一种方式和第二种方式效果是一样的，但推荐使用第一种方式。因为 <font>第一种方式设置 max_age 后，内部会转换成 datatime 类型，把 expires 也设置一遍，所以推荐使用第一种方式</font>。</p>
<p>( 2 ) 设置在某个 url 上读取 cookie</p>
<p>下面设置只有 <strong><code>/class/</code></strong> 的 url 才可以读取到 cookie：</p>
<pre><code class="py">def login(request):
    username = request.POST.get('username')
    pwd = request.POST.get('pwd')
    if request.method == 'POST':
        if username == 'thanlon' and pwd == '123456':
            obj = redirect('/classes/')
            obj.set_cookie('ticket', 'O2UikIFGGvHxcUQD7rIbgxedinIpEoMjStxoO579rgY8NeQM', path='/class/')
            return obj
    else:
        return render(request, 'login.html')
</code></pre>

<p>PS：<font>默认 <strong><code>path = '/'</code></strong> 表示所有url都可以读取到 cookie</font>。</p>
<p>( 3 ) 设置不同的域名访问 cookie，默认是当前域名，当然也可以设置子域名，表示只有子域名才可以获取到，一般用不到。</p>
<pre><code class="py">def login(request):
    username = request.POST.get('username')
    pwd = request.POST.get('pwd')
    if request.method == 'POST':
        if username == 'thanlon' and pwd == '123456':
            obj = redirect('/classes/')
            obj.set_cookie('ticket', 'O2UikIFGGvHxcUQD7rIbgxedinIpEoMjStxoO579rgY8NeQM',domain=)
            return obj
    else:
        return render(request, 'login.html')
</code></pre>

<p>( 4 ) 设置安全相关，httponly 表示写的 cookie 只能通过 http 来回发送，如果为 True，cookie 是写到浏览器上了，但是 <font>通过 javascript 找不到，没有权限对其进行操作</font>，当然可以通过抓包获取。secure 与 https 相关的，<font>网站如果是 https 的，要把secure设置为 True</font>。</p>
<pre><code class="py">def login(request):
    username = request.POST.get('username')
    pwd = request.POST.get('pwd')
    if request.method == 'POST':
        if username == 'thanlon' and pwd == '123456':
            obj = redirect('/classes/')
            obj.set_cookie('ticket', 'O2UikIFGGvHxcUQD7rIbgxedinIpEoMjStxoO579rgY8NeQM',httponly=False,secure=False)
            return obj
    else:
        return render(request, 'login.html')
</code></pre>

<hr>

<h5 id="3-cookie">3. 设置cookie的签名</h5>
<p>对 cookie 进行签名是指对cookie的值进行操作，使用 <kbd>set_signed_cookie()</kbd> 方法。Django 中默认使用的是时间戳来签名，当然也可以自定制签名，只需要自己定义一个类继承 <strong><code>TimestampSigner</code></strong>，然后重写 <kbd>sign</kbd> 和 <kbd>unsign</kbd> 方法。最后在配置文件文件中指定自己定义的类 <strong><code>SIGNING_BACKEND=Python文件名.类名</code></strong> 就可以了。下面是对 cookie 进行签名：</p>
<pre><code class="py">def classes(request):
    ticket = request.get_signed_cookie('ticket', salt='123456')
    if not ticket:
        return redirect('/login/')
 def login(request):
    username = request.POST.get('username')
    pwd = request.POST.get('pwd')
    if request.method == 'POST':
        if username == 'thanlon' and pwd == '123456':
            obj = redirect('/classes/')
            obj.set_signed_cookie('ticket', 'thanlon', salt='123456')
            return obj
    else:
        return render(request, 'login.html')
</code></pre>

<hr>

<h5 id="4-cookie">4. 基于cookie的登录验证</h5>
<pre><code class="py">def classes(request):
    '''
    查询班级id、班级名称
    '''
    # 获取cookie
    ticket = request.COOKIES.get('ticket')
    if not ticket:
        return redirect('/login/')
    conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='123456', db='test')
    cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)
    cursor.execute(&quot;select id,title from class&quot;)
    classes_list = cursor.fetchall()
    cursor.close()
    conn.close()
    return render(request, 'classes.html', {'classes_list': classes_list})

def login(request):
    '''
    登录
    '''
    username = request.POST.get('username')
    pwd = request.POST.get('pwd')
    if request.method == 'POST':
        if username == 'thanlon' and pwd == '123456':
            obj = redirect('/classes/')
            # 设置cookie
            obj.set_cookie('ticket', 'O2UikIFGGvHxcUQD7rIbgxedinIpEoMjStxoO579rgY8NeQM')
            return obj
    else:
        return render(request, 'login.html')
</code></pre>

<p>PS：读所有的 cookie 使用 request.COOKIES
<hr></p>
<h5 id="5-django_1">5. Django主流操作</h5>
<p>以上 Django 的使用中至少有两点是非主流操作的：<font>第一点体现在创建 app 上，第二点体现在数据库操作上</font>。以后，我们将使用Django的主流操作来进行开发。<font>创建 app 方面，使用命令的方式来创建</font>。<font>操作数据库方面，不再使用 pymysql 或者 SqlAchemy，而是使用 ORM</font>。
<hr></p>
<h4 id="_2">项目的创建和目录文件的介绍</h4>
<hr>

<h5 id="1-django_1">1. 创建一个完整的Django项目</h5>
<pre><code class="py"># 创建一个名为mysite的Django工程目录
thanlon@thanlon-master:~$ django-admin startproject mysite
# 进入工程目录
thanlon@thanlon-master:~$ cd mysite/
# 创建一个名为app01的Django应用程序
thanlon@thanlon-master:~/mysite$ python3 manage.py startapp app01
</code></pre>

<h5 id="2-django_1">2. Django主要相关目录文件介绍</h5>
<pre><code class="py">mysite/
    manage.py
    mysite/
        __init__.py
        settings.py
        urls.py
        asgi.py
        wsgi.py
</code></pre>

<p><strong><code>外部 mysite/</code></strong>：项目的容器，它的名称与 Django 无关；您可以将其重命名为任何喜欢的名称</p>
<p><strong><code>manage.py</code></strong>：一个命令行实用程序，可让您以各种方式与该 Django 项目进行交互</p>
<p><strong><code>内部 mysite/目录</code></strong>：项目的实际 Python 包，它的名称是 Python 包名称，您需要使用它来导入其中的任何内容（例如 mysite.urls）</p>
<p><strong><code>mysite/__init__.py</code></strong>：一个空文件，告诉 Python 该目录应视为 Python 软件包</p>
<p><strong><code>mysite/settings.py</code></strong>：此 Django 项目的设置/配置</p>
<p><strong><code>mysite/urls.py</code></strong>：此 Django 项目的 URL 声明，Django 支持的网站的“目录”</p>
<p><strong><code>mysite/asgi.py</code></strong>：与 ASGI 兼容的 Web 服务器为您的项目提供服务的入口点</p>
<p><strong><code>mysite/wsgi.py</code></strong>：兼容 WSGI 的 Web 服务器为您的项目提供服务的入口点</p>
<p><strong><code>migrations</code></strong>：与数据库相关，ORM 对数据表的操作记录会放到这个目录下</p>
<p><strong><code>admin.py</code></strong>：Django 自带后台管理相关配置</p>
<p><strong><code>models.py&lt;</code></strong>：与数据库表结构对应的类，根据类创建数据库表</p>
<p><strong><code>test.py</code></strong>：用作单元测试</p>
<p><strong><code>views.py</code></strong>：写视图函数，做业务处理。不一定只有一个 views.py，可以在app目录下单独创建一个 views 的目录用存放不同的视图函数。
<hr></p>
<h4 id="_3">路由系统</h4>
<hr>

<h5 id="1_2">1. 静态路由</h5>
<p>路由就是用户访问网站资源的路径，在Django中路由要和视图函数对应起来，路由和视图的对应关系有一对一和多对一。静态路由是比较常见的路由，不使用尖括号和正则表达式定义的路由，与视图函数是一对一关系。如默认的 <strong><code>/admin/</code></strong> 和我们自己定义的 <strong><code>/login/</code></strong>、<strong><code>edit/1/</code></strong>：</p>
<pre><code class="py">urlpatterns = [
    # 匹配admin/
    path('admin/', admin.site.urls),
    # 匹配login/
    path('login/', views.login),
    # 匹配edit/1
    path('edit/1', views.add_user),
    # 匹配edit/1/，和不加/是有区别的
    path('edit/1/', views.add_user),
]
</code></pre>

<p>注意：最后加不加 <strong><code>/</code></strong> 匹配到的路径是不同的。 
<hr></p>
<h5 id="2_2">2. 动态路由</h5>
<p>使用尖括号定义的路由是动态的，可以定义传入变量并且指定变量的类型，其它类型还有字符串，用 <strong><code>str</code></strong> 表示：</p>
<pre><code class="py">urlpatterns = [
    # 匹配任意整型，视图函数中必须用名为id的变量接收，当然也可以使用万能的**kwargs来接收,转换成字典后再找到索引id的值即为传入的参数
    path('add-user/&lt;int:id&gt;', views.add_user),
    # 匹配任意整型，和不加/是有区别的
    path('add-user/&lt;int:id&gt;/', views.add_user),
    # 匹配任意字符串类型
    path('add-user/&lt;str:str_name&gt;', views.add_user),
    # 匹配任意字符串类型，和不加/是有区别的
    path('add-user/&lt;str:str_name&gt;/', views.add_user),
]
</code></pre>

<p>PS：尖括号的方式下也可以使用转换器，可以自定义转换器，暂时用不到就不说。</p>
<p>使用正则表达式定义的路由也是动态的，同样可以实现多个路由对应一个视图函数。Django3.0 版本使用正则表达式定义路由需要使用到 <strong><code>re_path</code></strong>：</p>
<pre><code class="py">from django.urls import path, re_path

urlpatterns = [
    # 如果只想匹配add-user，可以在最后加上终止符号$
    re_path('^add-user$', views.add_user),
    # 可以匹配到add-user/
    re_path('^add-user/', views.add_user),
    # 可以匹配到add-user，也可以匹配到add-user/
    re_path('^add-user', views.add_user),
    # 匹配任意一位数字
    re_path('^add-user/(\d)/', views.add_user),
    # 匹配任意数字，数字会被当作传参传递，add_user方法中必须有形式参数接收
    re_path('^add-user/(\d+)/', views.add_user),
    # 匹配任意一个字符(大小写)，字符会被当作传参传递，add_user方法中必须有形式参数接收
    re_path('^add-user/([A-Za-z])/', views.add_user),
    # 伪静态匹配数字.html，数字部分会被当作传参传递，add_user方法中必须有形式参数接收
    re_path('^add-user/(\d+).html$', views.add_user),
    # 伪静态匹配任意字符串.html，字符串中也可以只有一个字符，字符串部分会被当作传参传递，add_user方法中必须有形式参数接收
    re_path('^add-user/(\w+).html$', views.add_user),
    # 位置传参，所以视图函数中形参必须有a和b接收,a、b的位置随意。注意如果是'^add-user/(\d+)/(?P&lt;b&gt;\d+)，视图是不接收(\d+)部分的参数。
    re_path('^add-user/(?P&lt;a&gt;\d+)/(?P&lt;b&gt;\d+)', views.add_user),
]
</code></pre>

<p>注意：<font>Django中的路径匹配是顺序匹配</font>。也就是从上到下匹配，上面的路由匹配成功就停止匹配下面的路由。
<hr></p>
<h5 id="3_2">3. 路由分发</h5>
<p>多个 app 时可以使用路由分发，可以实现不同应用使用不同的路由，方便管理路由。可以在 app01 目录下新建 <strong><code>urls.py</code></strong> 文件用作 app01 应用的路由：</p>
<pre><code class="py">urlpatterns = [
    path('login/', views.login),
]
</code></pre>

<p>在主要的 <strong><code>urls.py</code></strong> 文件中要导入 include 函数才能实现路由的分发：</p>
<pre><code class="py">from django.urls import path, include

urlpatterns = [
    # 注意路由后面必须加上/
    path('app01/', include('app01.urls'))
]
</code></pre>

<p>下面就可以通过 <font>http://127.0.0.1:8000/app01/login/</font> 来访问 app01 下的视图函数 login，这样就实现了路由的分发。
<hr></p>
<h5 id="4_1">4. 反向生成路由</h5>
<p>在写路由的时候，给路由命个名字，以后可使用这个名字找到这个路由，在存储用户路由信息的信息也可以存储路由的名字，节约空间，方便使用。<font>可以在 Python 代码中反向生成路由，也可以在模板中反向生成路由</font>。</p>
<p>( 1 ) 在Python代码中使用。需要设置路由、业务逻辑：
<strong><code>urls.py:</code></strong></p>
<pre><code class="py">urlpatterns = [
    path('index/', views.index, name=&quot;index&quot;),
]
</code></pre>

<p><strong><code>views.py:</code></strong></p>
<pre><code class="py">def index(request, id):
    v = reverse('index_id', kwargs={'id': id})
    print(v)  # /index/1/
    return HttpResponse('成功执行！')
</code></pre>

<p>( 2 ) 在模板中使用。需要设置路由、写视图逻辑和模板：</p>
<p><strong><code>urls.py:</code></strong></p>
<pre><code class="py">urlpatterns = [
    path('index/', views.index, name=&quot;index&quot;),
]
</code></pre>

<p><strong><code>views.py:</code></strong></p>
<pre><code class="py">def index(request):
    return render(request, 'index.html')
</code></pre>

<p><strong><code>index.html:</code></strong></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{% url 'index' %} # 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>如果路由中没有传值，模板中可以使用上面的方式。但是，如果路由中有传值，如：</p>
<p><strong><code>urls.py:</code></strong></p>
<pre><code class="py">urlpatterns = [
    path('index/&lt;int:id&gt;/', views.index, name=&quot;index&quot;),
]
</code></pre>

<p><strong><code>views.py:</code></strong></p>
<pre><code class="py">def index(request,id):
    # v = reverse('index_id', kwargs={'id': id})
    # print(v)  # /index/1/
    # print(id)
    # 把id传到模板中
    return render(request,'index.html',{'id':id})
</code></pre>

<p>模板中反向生成路由的方式：</p>
<p><strong><code>index.html:</code></strong></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{% url 'index' id %}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>注意：如果有多个参数，在id后面追加就可以，使用空格隔开，如：<strong><code>{% url 'index' id page %}</code></strong>
<hr></p>
<h4 id="orm">ORM操作</h4>
<hr>

<h5 id="1-orm">1. ORM的功能</h5>
<p>Django 的ORM 可以操作数据库的表结构和数据行。操作表结构体现在创建表、修改表和删除表，操作数据行则体现在对表的 CURD 操作，也就是增删改查。<font>Django 的 ORM 本身不支持连接数据库，实质上使用的是第三方工具如 pymysql 或者是 sqlalchemy 来连接数据库</font>。
<hr></p>
<h5 id="2_3">2. 数据库设置</h5>
<p>Django 默认使用的是 SQLite，也是 Django 中自带的数据库，但是我们一般不会使用。我们通常会使用 SQLite 之外的数据库，如 mysql、oracle、postgresql 等。所以，需要在 Django 中修改默认使用的 SQLite 为其它的数据库。在 <strong><code>settings.py</code></strong> 中找到 <strong><code>DATABASES</code></strong> 变量：</p>
<pre><code class="py">DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
</code></pre>

<p>如果使用的是 mysql 数据，修改为：</p>
<pre><code class="py">DATABASES = {
    'default': {
        # 'ENGINE': 'django.db.backends.sqlite3',
        'ENGINE': 'django.db.backends.mysql',
        'NAME': '数据库的名称',
        'USER': '用户名',
        'PASSWORD': '密码',
        'HOST': '数据库地址',
        'PORT': '数据库端口'
    }
}
</code></pre>

<p>设置ORM使用 <strong><code>pymysql</code></strong> 连接数据库，只需要在与 <strong><code>settings.py</code></strong> 同级目录下的 <strong><code>__init__.py</code></strong> 这个空文件中写入：</p>
<pre><code class="py">import pymysql
pymysql.install_as_MySQLdb()
</code></pre>

<p>配置文件 <strong><code>setting.py</code></strong> 中的 <strong><code>INSTALLED_APPS</code></strong> 下包含了在 Django 实例中激活的所有 Django 应用程序的名称，这些应用程序都是随 Django 一起提供的：</p>
<p>django.contrib.admin：管理站点</p>
<p>django.contrib.auth：认证系统</p>
<p>django.contrib.contenttypes ：内容类型的框架</p>
<p>django.contrib.sessions：会话框架</p>
<p>django.contrib.messages：消息传递框架</p>
<p>django.contrib.staticfiles：用于管理静态文件的框架</p>
<p>这些应用中的一些应用程序 <font>至少使用一个数据库表</font>，因此我们需要在数据库中创建表之后才能使用它们，执行下面的命令来创建：</p>
<pre><code class="py">(django_test) thanlon@thanlon:~/projects/PycharmProjects/django_test$ python manage.py migrate
</code></pre>

<p>可以在数据库看到创建的数据表：</p>
<pre><code class="sql">mysql&gt; show tables;
+----------------------------+
| Tables_in_django_test      |
+----------------------------+
| auth_group                 |
| auth_group_permissions     |
| auth_permission            |
| auth_user                  |
| auth_user_groups           |
| auth_user_user_permissions |
| django_admin_log           |
| django_content_type        |
| django_migrations          |
| django_session             |
+----------------------------+
10 rows in set (0.00 sec)
</code></pre>

<p>migrate 命令获取所有尚未应用的迁移（Django 使用名为的特殊表在数据库中跟踪应用了哪些迁移 django_migrations），并针对数据库运行它们。本质上，将你对模型所做的更改与数据库。迁移功能非常强大，可以在开发项目时随时间更改模型，而无需删除数据库或表并创建新的模型。它专门用于实时升级数据库而不会丢失数据。
<hr></p>
<h5 id="3-makemigrationsmigrate">3. makemigrations和migrate</h5>
<p>接下来需要到模型中创建类和字段，创建完成后需要先使用 <strong><code>python manage.py makemigrations</code></strong> 命令来为数据表的更改创建迁移，然后使用 <strong><code>python manage.py migrate</code></strong> 将更改应用到数据库。之所以使用单独的命令来进行和应用迁移，是因为你会将迁移提交到版本控制系统，并随应用程序一起交付。<font>这些单独的命令不仅使您的开发更加容易，而且还可以被其他开发人员和生产环境使用</font>。
<hr></p>
<h5 id="4-orm">4. ORM创建数据表</h5>
<p>在 <strong><code>models.py</code></strong> 文件中写模型，这里分别创建员工表和部门表：</p>
<pre><code class="py">from django.db import models

class Depart(models.Model):
    &quot;&quot;&quot;
    创建部门表
    &quot;&quot;&quot;
    title = models.CharField(max_length=32, unique=True)

class EmpInfo(models.Model):
    &quot;&quot;&quot;
    创建员工信息表
    &quot;&quot;&quot;
    # 主键默认是id，写与不写名字都是id，类型是int且为主键和自动递增
    nid = models.AutoField(primary_key=True)
    username = models.CharField(max_length=32)
    pwd = models.CharField(max_length=64)
    # 'max_length' is ignored when used with IntegerField.
    age = models.IntegerField()
    # 会自动创建dp_id字段
    dp = models.ForeignKey(&quot;Depart&quot;, on_delete=models.CASCADE, null=True)
</code></pre>

<p>执行创建迁移和应用更改的命令后会创建两张表：</p>
<pre><code class="sql">部门表：
+-------+-------------+------+-----+---------+----------------+
| Field | Type        | Null | Key | Default | Extra          |
+-------+-------------+------+-----+---------+----------------+
| id    | int         | NO   | PRI | NULL    | auto_increment |
| title | varchar(32) | NO   | UNI | NULL    |                |
+-------+-------------+------+-----+---------+----------------+
员工表：
+----------+-------------+------+-----+---------+----------------+
| Field    | Type        | Null | Key | Default | Extra          |
+----------+-------------+------+-----+---------+----------------+
| nid      | int         | NO   | PRI | NULL    | auto_increment |
| username | varchar(32) | NO   |     | NULL    |                |
| pwd      | varchar(64) | NO   |     | NULL    |                |
| age      | int         | NO   |     | NULL    |                |
| dp_id    | int         | YES  | MUL | NULL    |                |
+----------+-------------+------+-----+---------+----------------+
</code></pre>

<hr>

<h5 id="5-ormcurd">5. ORM单表CURD</h5>
<p>数据的增加：</p>
<pre><code class="py">from django.shortcuts import render, HttpResponse, reverse
from app01 import models

# Create your views here.
def index(request):
    models.Depart.objects.create(title='技术部')
    models.Depart.objects.create(title='运维部')
    models.EmpInfo.objects.create(username='Thanlon', pwd='123456', age=23, dp_id=3)
    return render(request, 'index.html')
</code></pre>

<pre><code class="sql">部门表：
+----+-----------+
| id | title     |
+----+-----------+
|  2 | 技术部    |
|  1 | 运维部    |
+----+-----------+
员工表：
+-----+----------+--------+-----+-------+
| nid | username | pwd    | age | dp_id |
+-----+----------+--------+-----+-------+
|   1 | Thanlon  | 123456 |  23 |     1 |
+-----+----------+--------+-----+-------+
</code></pre>

<p>数据的查询：</p>
<pre><code class="py">from django.shortcuts import render, HttpResponse, reverse
from app01 import models

def index(request):
    # 查询所有部门信息
    dp_list = models.Depart.objects.all()
    print(dp_list)  # &lt;QuerySet [&lt;Depart: Depart object (2)&gt;, &lt;Depart: Depart object (1)&gt;]&gt;
    for item in dp_list:
        print(item.id, item.title)
        &quot;&quot;&quot;
        2 技术部
        1 运维部
        &quot;&quot;&quot;
    # 查询满足条件的数据行
    # emp_list_id = models.EmpInfo.objects.filter(name='thanlon').first()
    # dp_list_id = models.Depart.objects.filter(id=1)
    # dp_list_id = models.Depart.objects.filter(id__lt=2)
    dp_list_id = models.Depart.objects.filter(id__gt=1)
    for item in dp_list_id:
        print(item.id, item.title)  # 2 技术部
    return render(request, 'index.html')
</code></pre>

<p>数据的删除：</p>
<pre><code class="py">from django.shortcuts import render, HttpResponse, reverse
from app01 import models

# Create your views here.
def index(request):
    # 删除id=2的部门
    models.Depart.objects.filter(id=2).delete()
    return render(request, 'index.html')
</code></pre>

<pre><code class="sql">+----+-----------+
| id | title     |
+----+-----------+
|  1 | 运维部    |
+----+-----------+
</code></pre>

<p>数据表的修改：</p>
<pre><code class="py">from django.shortcuts import render, HttpResponse, reverse
from app01 import models

# Create your views here.
def index(request):
    # 修改id=1的部门信息
    models.Depart.objects.filter(id=1).update(title=&quot;人事部&quot;)
    return render(request, 'index.html')
</code></pre>

<pre><code class="sql">+----+-----------+
| id | title     |
+----+-----------+
|  1 | 人事部    |
+----+-----------+
</code></pre>

<hr>

<h5 id="6">6. 正向连表操作</h5>
<p>创建用户表和用户类型表，用户类型表是用户表的父表，用户表是用户类型的字表。</p>
<p><strong><code>models.py:</code></strong></p>
<pre><code class="py">class UserType(models.Model):
    &quot;&quot;&quot;
    用户类型表
    &quot;&quot;&quot;
    title = models.CharField(max_length=32)

class UserInfo(models.Model):
    &quot;&quot;&quot;
    用户表
    &quot;&quot;&quot;
    name = models.CharField(max_length=16)
    age = models.IntegerField()
    ut = models.ForeignKey('UserType', on_delete=models.CASCADE)
</code></pre>

<p><strong><code>views.py:</code></strong>：</p>
<pre><code class="py">def user(request):
    models.UserType.objects.create(title='普通用户')
    models.UserType.objects.create(title='VIP用户')
    models.UserInfo.objects.create(name='Thanlon', age=20, ut_id=1)
    models.UserInfo.objects.create(name='Kiku', age=23, ut_id=2)
    return HttpResponse('...')
</code></pre>

<p>正向连表查的是 UserInfo 表，是通过 UserInfo 表的外健 ut 字段来获取父表与之对应的字段。<font>一个用户只有一个用户类型</font>。</p>
<pre><code class="py">def user(request):
    result = models.UserInfo.objects.all()
    for obj in result:
        # print(obj.id,obj.name,obj.age,obj.ut,obj.ut.id,obj.ut.title)
        # 如果UserType还有父表则继续使用.的方式获取父表的值(三个表,四个表...都可以通过这种方式)
        print(obj.id, obj.name, obj.age, obj.ut.title)
    &quot;&quot;&quot;
    2 Thanlon 20 普通用户
    3 Kiku 23 VIP用户
    &quot;&quot;&quot;
    return HttpResponse('...')
</code></pre>

<h5 id="7_1">7. 反向连表操作</h5>
<p>反向连表查询的父表 UserType，通过父表隐藏的字段来获取子表 UserInfo 的字段，这个“隐藏”的字段的格式是 <strong><code>表名_set</code></strong>。<font>一个用户类型下可以有多个用户</font>。</p>
<pre><code class="py">def user(request):
    # 一个用户类型下可以有多个用户
    # obj = models.UserType.objects.first()
    # print(obj.id, obj.title, obj.userinfo_set.all())
    &quot;&quot;&quot;
      1 普通用户 &lt;QuerySet [&lt;UserInfo: UserInfo object (2)&gt;]&gt;
    &quot;&quot;&quot;
    # 查所有用户类型下所有的用户
    result = models.UserType.objects.all()
    for obj in result:
        for row in obj.userinfo_set.all():
            print(row.id, row.name, row.age, row.ut.title)
    &quot;&quot;&quot;
    2 Thanlon 20 普通用户
    3 Kiku 23 VIP用户
    &quot;&quot;&quot;
    return HttpResponse('...')
</code></pre>

<p>如果是查 Userinfo 的所有字段，使用反向连表和正向连表都能查询到结果，但是我们发现反向连表的时间复杂度比正向连表要大。</p>
<p>反向连表可以获取用户类型下对应的所有用户，还可以通过过滤这些用户：</p>
<pre><code class="py">def user(request):
    obj = models.UserType.objects.first()
    print(obj.id, obj.title, obj.userinfo_set.filter(name='Thanlon'))
    for row in obj.userinfo_set.filter(name='Thanlon'):
        print(row.id, row.name, row.ut.title)
    &quot;&quot;&quot;
    1 普通用户 &lt;QuerySet [&lt;UserInfo: UserInfo object (2)&gt;]&gt;
    2 Thanlon 普通用户
    &quot;&quot;&quot;
    return HttpResponse('...')
</code></pre>

<hr>

<h5 id="8_1">8. 获取数据的三种方式</h5>
<p>第一种方式，获取的是对象：</p>
<pre><code class="py">def user(request):
    result = models.UserType.objects.all()
    print(result)  # [obj,obj,obj,,,]
    &quot;&quot;&quot;
    &lt;QuerySet [&lt;UserInfo: UserInfo object (2)&gt;, &lt;UserInfo: UserInfo object (3)&gt;]&gt;
    &quot;&quot;&quot;
    for obj in result:
        for row in obj.userinfo_set.all():
            print(row.id, row.name, row.ut.title)
    &quot;&quot;&quot;
    2 Thanlon 普通用户
    3 Kiku VIP用户
    &quot;&quot;&quot;
    return HttpResponse('...')
</code></pre>

<p>第二种方式，获取的是字典：</p>
<pre><code class="py">def user(request):
    # 获取所有字段
    # result = models.UserInfo.objects.values()
    # 获取指定字段
    result = models.UserInfo.objects.values('age', 'name', 'ut__title')
    print(
        result)  # [{'age': 20, 'name': 'Thanlon', 'ut__title': '普通用户'}, {'age': 23, 'name': 'Kiku', 'ut__title': 'VIP用户'}]
    &quot;&quot;&quot;
    &lt;QuerySet [{'age': 20, 'name': 'Thanlon', 'ut__title': '普通用户'}, {'age': 23, 'name': 'Kiku', 'ut__title': 'VIP用户'}]&gt;
    &quot;&quot;&quot;
    for row in result:
        print(row['age'], row['name'], row['ut__title'])
    &quot;&quot;&quot;
    20 Thanlon 普通用户
    23 Kiku VIP用户
    &quot;&quot;&quot;
    return HttpResponse('...')
</code></pre>

<p>第三种方式，获取的是元组：</p>
<pre><code class="py">def user(request):
    # 获取所有字段
    # result = models.UserInfo.objects.values_list()
    # 获取指定字段
    result = models.UserInfo.objects.values_list('age', 'name', 'ut__title')
    print(result)  # [(20, 'Thanlon', '普通用户'), (23, 'Kiku', 'VIP用户')]
    &quot;&quot;&quot;
    &lt;QuerySet [(20, 'Thanlon', '普通用户'), (23, 'Kiku', 'VIP用户')]&gt;
    &quot;&quot;&quot;
    for row in result:
        print(row[0], row[1], row[2])
    &quot;&quot;&quot;
    20 Thanlon 普通用户
    23 Kiku VIP用户
    &quot;&quot;&quot;
    return HttpResponse('...')
</code></pre>

<p>三种方式都支持跨表操作，只不过对象的方式跨表是在循环对象的时候，而字典和元组的方式是在查询的的时候。
<hr></p>
<h4 id="cbv">CBV的使用</h4>
<hr>

<h5 id="1-cbv">1. CBV的引入</h5>
<p>FBV 即 Function-Based-View，是 <font>通过函数来处理请求</font>。CBV 即 Class-Based-View，是 <font>通过类来处理请求</font>。相对于传统的 FBV 方式，CBV的优点体现在：① 提高了代码的复用性，可以使用面向对象的技术，比如Mixin（多继承）；② 可以用不同的函数针对不同的HTTP方法处理，而不是通过很多if判断，提高代码可读性。
<hr></p>
<h5 id="2-cbv">2. CBV的应用</h5>
<p>登录功能的实现，定义一个 Login 类用于处理用户的登录请求。路由 URL 匹配成功后，开始匹配请求的方法 method。如果是 GET 请求，执行 Login 类的 get 方法，获取到登录页面。如果是 POST 请求，将登录表单的数据发送到后台验证。无须使用 if 语句来判断请求的方法是什么：</p>
<p><strong><code>urls.py</code></strong>：</p>
<pre><code class="py">from django.contrib import admin
from django.urls import path
from app01 import views

urlpatterns = [
    path('login.html/', views.Login.as_view()),
]
</code></pre>

<p><strong><code>views.py</code></strong>：</p>
<pre><code class="py">class Login(View):
    &quot;&quot;&quot;
    get：查询
    post：创建
    put：更新
    delete：删除
    &quot;&quot;&quot;

    def get(self, request):
        &quot;&quot;&quot;
        请求的方法是get时执行
        :param request:
        :return:
        &quot;&quot;&quot;
        return render(request, 'login.html')

    def post(self, request):
        &quot;&quot;&quot;
        请求的方法是post时执行
        :param request:
        :return:
        &quot;&quot;&quot;
        username = request.POST.get('username')
        print(username)
        return HttpResponse('登录成功！')
</code></pre>

<p><strong><code>login.html</code></strong>：</p>
<pre><code class="html">...
&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-md-4 col-md-offset-4&quot;&gt;
            &lt;div class=&quot;panel panel-danger&quot;&gt;
                &lt;div class=&quot;panel-heading&quot; style=&quot;font-weight: bold&quot;&gt;用户登录
                    &lt;button type=&quot;button&quot; class=&quot;close&quot; id=&quot;close_add_modal&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
                &lt;div class=&quot;panel-body&quot;&gt;
                    &lt;form method=&quot;post&quot;&gt;
                        &lt;div class=&quot;form-group&quot;&gt;
                            &lt;label for=&quot;&quot;&gt;用户名&lt;/label&gt;
                            &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; id=&quot;name&quot; placeholder=&quot;请输入用户名&quot;
                                   autofocus&gt;
                        &lt;/div&gt;
                        &lt;div class=&quot;form-group&quot;&gt;
                            &lt;label for=&quot;&quot;&gt;密码&lt;/label&gt;
                            &lt;input type=&quot;password&quot; name=&quot;pwd&quot; class=&quot;form-control&quot; id=&quot;pwd&quot; placeholder=&quot;请输入密码&quot;&gt;
                        &lt;/div&gt;
                        &lt;input type=&quot;submit&quot; class=&quot;btn&quot; value=&quot;登录&quot; id=&quot;add_student&quot; style=&quot;background: #f2dede;&quot;&gt;
                    &lt;/form&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
...
</code></pre>

<p>表单只支持POST和GET方式提交！AJAX支持所有的请求！
<hr></p>
<h5 id="3-dispatch">3. dispatch方法</h5>
<p>请求的方法有很多，如果使用 if 来一一判断就要写很多判断语句。但是，实际上使用的并不是条件判断，而是 <font>反射</font>。用户发送请求，URL 会匹配到类。找类中的方法时，<font>使用getattr方法判断请求的方法是否对应类中的方法</font>。查看源码的时候发现在执行 get 和 post 方法之前，还执行了 dispatch 方法。dispatch 方法里执行就是这个操作：</p>
<pre><code class="py">def dispatch(self, request, *args, **kwargs):
    # Try to dispatch to the right method; if a method doesn't exist,
    # defer to the error handler. Also defer to the error handler if the
    # request method isn't on the approved list.
    if request.method.lower() in self.http_method_names:
        # 在当前对象中找用户提交的方法request.method.lower(),handler就是找到的方法名
        handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
    else:
        handler = self.http_method_not_allowed
    # handler加括号就是执行这些方法
    return handler(request, *args, **kwargs)
</code></pre>

<p>dispatch 方法的功能类似 <font>装饰器</font> 的功能，在执行请求的方法之前和之后做其它操作：</p>
<pre><code class="py">class Login(View):

    def dispatch(self, request, *args, **kwargs):
        print('Before')
        obj = super(Login, self).dispatch(request, *args, **kwargs)
        print('After')
        return obj

    def get(self, request):
        print('get')
        return render(request, 'login.html')

    def post(self, request):
        print('post')
        return HttpResponse('登录成功！')
</code></pre>

<p>执行记录：</p>
<pre><code class="py">[06 / Jun / 2020 01: 32:33] &quot;GET /login.html/ HTTP/1.1&quot; 200 1813
Before
get
After
[06 / Jun / 2020 01: 32:38] &quot;GET /login.html/ HTTP/1.1&quot; 200 1813
[06 / Jun / 2020 01: 32:41] &quot;POST /login.html/ HTTP/1.1&quot; 200 15
Before
post
After
</code></pre>

<p>如果要对 get 和 post 等请求方法做批量操作时，<font>没必要在每个方法中都写一遍，只要在 dispatch 写一遍就可以了</font>。
<hr></p>
<h5 id="4-cbv">4. CBV中添加装饰器</h5>
<p>CBV 中添加装饰器有两种方法，分别是在指定的方法中添加装饰器和在类上添加装饰器。在方法中添加装饰器：</p>
<p><strong><code>views.py:</code></strong></p>
<pre><code class="py">from django.views import View
from django.views.decorators.csrf import csrf_protect
from django.utils.decorators import method_decorator

def wrapper(func):
    def inner(*args, **kwargs):
        return func(*args, **kwargs)
    return inner

class Login(View):
    @method_decorator(csrf_protect)
    def get(self, request):
        pass

    @method_decorator(wrapper)
    def post(self, request):
        pass
</code></pre>

<p>在类上添加装饰器不可以直接把装饰器放在类上，这样时错误的，如:</p>
<pre><code class="py">from django.views import View
from django.views.decorators.csrf import csrf_protect

@csrf_protect
class Login(View):
    def get(self, request):
        pass

    def post(self, request):
        pass
</code></pre>

<p>在类上加装饰器，需要用到 <strong><code>@method_decorator</code></strong>:</p>
<pre><code class="py">from django.views import View
from django.views.decorators.csrf import csrf_protect
from django.utils.decorators import method_decorator

# 对类中所有的方法添加csrf_protect装饰器
@method_decorator(csrf_protect)
class Login(View):
    def get(self, request):
        pass

    def post(self, request):
        pass
</code></pre>

<p>还可以通过类方法名称来指定方法添加装饰器：</p>
<pre><code class="py">from django.views import View
from django.views.decorators.csrf import csrf_protect
from django.utils.decorators import method_decorator

@method_decorator(csrf_protect, name='get')
@method_decorator(csrf_protect, name='post')
class Login(View):
    def get(self, request):
        pass

    def post(self, request):
        pass
</code></pre>

<p>csrf的装饰器在使用CBV的情况下不能加到类方法上!</p>
<p>以上两种方法都具有为所有的函数加装饰器的功能，不过如果 <font>想为所有类方法添加装饰器显得比较麻烦!</font> 这里还有一种方法可以 <font>为所有的方法加上某个装饰器</font>，那就是把装饰器加到 dispatch 方法上：</p>
<pre><code class="py">from django.views import View
from django.views.decorators.csrf import csrf_protect
from django.utils.decorators import method_decorator

def wrapper(func):
    def inner(*args, **kwargs):
        return func(*args, **kwargs)
    return inner

@method_decorator(csrf_protect, name='dispatch')
@method_decorator(wrapper, name='dispatch')
class Login(View):
    def get(self, request):
        pass

    def post(self, request):
        pass
</code></pre>

<hr>

<h4 id="_4">内置分页</h4>
<hr>

<h5 id="1_3">1. 后台分页逻辑</h5>
<pre><code class="py">from django.core.paginator import Paginator, PageNotAnInteger, EmptyPage

def student(request):
    # 获取所有的结果集
    emp_list = models.StuInfo.objects.all()  # &lt;QuerySet [&lt;StuInfo: StuInfo object (1)&gt;]&gt;
    &quot;&quot;&quot;
    emp_list也可以是使用pymysql拿到的列表：student_list = cursor.fetchall()
    [{'id': 1, 'name': '超越'}, {'id': 2, 'name': '奈何'}] &lt;class 'list'&gt;
    &quot;&quot;&quot;
    # 创建Paginator对象，可直接设置每页显示的条目数量
    pagenator = Paginator(emp_list, 3) 
    &quot;&quot;&quot;
    pagenator.page(1)：显示第1页

    pagenator.per_page：每页显示的条目数量
    pagenator.count：数据总个数
    pagenator.num_pages：总页数
    pagenator.page_range：总页数的索引范围，如(1,10)
    &quot;&quot;&quot;
    # 获取传入的页码
    current_page = request.GET.get('page')
    try:
        posts = pagenator.page(current_page)
    except PageNotAnInteger as e:
        posts = pagenator.page(1)  # 如果传入的页码不是整型，则默认显示第一页，如传入的是/student.html/?page=abc，/student.html/
    &quot;&quot;&quot;
    posts.has_next：是否有下一页
    posts.next_page_number：下一页页码
    posts.has_previous：是否有上一页
    posts.previous_page_number：上一页页码
    posts.object_list：分页之后的数据列表

    posts.number:当前页
    posts.paginator：paginator对象
    &quot;&quot;&quot;
    # 如果传入的页码不是int类型，如传入的是/student.html/?page=abc
    except EmptyPage as e:
        posts = pagenator.page(1)  # 如果传入的页码是空页，则默认显示第一页，如传入的是/student.html/?page=-10
    return render(request, 'student.html', {'posts': posts})
</code></pre>

<hr>

<h5 id="2_4">2. 前台分页展示</h5>
<pre><code class="html">&lt;table class=&quot;table table-hover text-center&quot; style=&quot;background: white;margin-bottom: 0&quot;&gt;
    &lt;tr&gt;
        &lt;th class=&quot;text-center&quot;&gt;ID&lt;/th&gt;
        &lt;th class=&quot;text-center&quot;&gt;姓名&lt;/th&gt;
        &lt;th class=&quot;text-center&quot;&gt;年龄&lt;/th&gt;
    &lt;/tr&gt;
    {% for row in posts.object_list %}
        &lt;tr&gt;
            &lt;td&gt;{{ row.id }}&lt;/td&gt;
            &lt;td&gt;{{ row.name }}&lt;/td&gt;
            &lt;td&gt;{{ row.age }}&lt;/td&gt;
        &lt;/tr&gt;
    {% endfor %}
&lt;/table&gt;
&lt;nav aria-label=&quot;Page navigation&quot; class=&quot;text-left&quot;&gt;
    &lt;ul class=&quot;pagination&quot;&gt;
        {% if posts.has_previous %}
            &lt;li&gt;
                &lt;a href=&quot;/student.html?page={{ posts.previous_page_number }}&quot;&gt;上一页&lt;/a&gt;
            &lt;/li&gt;
        {% endif %}
        {% if posts.has_next %}
            &lt;li&gt;
                &lt;a href=&quot;/student.html?page={{ posts.next_page_number }}&quot;&gt;下一页&lt;/a&gt;
            &lt;/li&gt;
        {% endif %}
    &lt;/ul&gt;
&lt;/nav&gt;
</code></pre>

<hr>

<h4 id="_5">自定义分页</h4>
<hr>

<h5 id="1_4">1. 自定义分页效果</h5>
<p>可以实现查找 <font>首页和最后一页，上一页和下一页，以及指定页</font>：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200614162457430.png" />
<hr></p>
<h5 id="2_5">2. 自定义分页的实现</h5>
<p>模型 Model 部分的代码：</p>
<p><strong><code>models.py</code></strong>:</p>
<pre><code class="py">from django.db import models

class UserType(models.Model):
    &quot;&quot;&quot;
    用户类型表
    &quot;&quot;&quot;
    title = models.CharField(max_length=32)

class UserInfo(models.Model):
    &quot;&quot;&quot;
    用户表
    &quot;&quot;&quot;
    name = models.CharField(max_length=16)
    age = models.IntegerField()
    ut = models.ForeignKey('UserType', on_delete=models.CASCADE)
</code></pre>

<p>控制器 Controller 部分的代码：</p>
<p><strong><code>vews.py</code></strong>:</p>
<pre><code class="py">from django.shortcuts import render, HttpResponse
from app01 import models
from utils.pagger import PageInfo


class PageInfo:
    def __init__(self, current_page, per_page, count_sum, base_url, show_page=11):
        &quot;&quot;&quot;
        :param current_page:当前的页码
        :param per_page:每页显示的数据量
        :param count_sum:总的数据量
        &quot;&quot;&quot;
        try:
            self.current_page = int(current_page)
        except Exception as e:
            self.current_page = 1
        self.per_page = per_page
        self.count_sum = count_sum
        a, b = divmod(count_sum, per_page)
        if b:
            a += 1
        # page_num：所有页码的数量
        self.sum_page_num = a
        self.show_page = show_page
        self.base_url = base_url

    def start(self):
        return (self.current_page - 1) * self.per_page

    def end(self):
        return self.current_page * self.per_page

    def pager(self):
        half = int((self.show_page - 1) / 2)
        # 如果总页数小于11
        if self.sum_page_num &lt; self.show_page:
            begin = 1
            stop = self.sum_page_num + 1
        else:
            if self.current_page &lt;= half:
                begin = 1
                stop = self.show_page + 1
            else:
                if self.current_page + half &gt; self.sum_page_num:
                    begin = self.sum_page_num - self.show_page + 1
                    stop = self.sum_page_num + 1
                else:
                    begin = self.current_page - half
                    stop = self.current_page + half + 1
        page_num_list = []
        index_page = '&lt;li&gt;&lt;a href=&quot;%s?page=1&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;首页&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;' % (self.base_url)
        page_num_list.append(index_page)
        if self.current_page &lt;= 1:
            prev_page = '&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;'
        else:
            prev_page = '&lt;li&gt;&lt;a href=&quot;%s?page=%s&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;' % (
                self.base_url, self.current_page - 1,)

        page_num_list.append(prev_page)
        for i in range(begin, stop):
            if i == self.current_page:
                page_num_list.append(
                    &quot;&lt;li class='active'&gt;&lt;a class='active' href='%s?page=%s'&gt;%s&lt;/a&gt;&lt;/li&gt;&quot; % (self.base_url, i, i))
            else:
                page_num_list.append(&quot;&lt;li&gt;&lt;a class='active' href='%s?page=%s'&gt;%s&lt;/a&gt;&lt;/li&gt;&quot; % (self.base_url, i, i))
        if self.current_page &gt;= self.sum_page_num:
            next_page = '&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;'
        else:
            next_page = '&lt;li&gt;&lt;a href=&quot;%s?page=%s&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;' % (
                self.base_url, self.current_page + 1,)
        page_num_list.append(next_page)

        final_page = '&lt;li&gt;&lt;a href=&quot;%s?page=%s&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;最后一页&lt;/a&gt;&lt;/li&gt;' % (
            self.base_url, self.sum_page_num)
        page_num_list.append(final_page)
        return ''.join(page_num_list)


def index(request):
    count_sum = models.UserInfo.objects.count()
    page_info = PageInfo(request.GET.get('page'), 1, count_sum, '/index.html')
    user_info = models.UserInfo.objects.all()[page_info.start():page_info.end()]
    return render(request, 'index.html', {'user_info': user_info, 'page_info': page_info})

</code></pre>

<p>视图 View 部分的代码：</p>
<pre><code class="html">...
&lt;table class=&quot;table table-bordered&quot;&gt;
    &lt;tr&gt;
        &lt;th&gt;用户名&lt;/th&gt;
        &lt;th&gt;年龄&lt;/th&gt;
    &lt;/tr&gt;
    {% for item in user_info %}
        &lt;tr&gt;
            &lt;td&gt; {{ item.name }}&lt;/td&gt;
            &lt;td&gt; {{ item.age }}&lt;/td&gt;
        &lt;/tr&gt;
    {% endfor %}
&lt;/table&gt;
&lt;nav aria-label=&quot;Page navigation&quot;&gt;
    &lt;ul class=&quot;pagination&quot;&gt;
        {{ page_info.pager|safe }}
    &lt;/ul&gt;
&lt;/nav&gt;
...
</code></pre>

<hr>

<h5 id="3_3">3. 分页插件</h5>
<p>可以把控制器部分的 PageInfo 类放在单独的 Python 文件中，可以复用。新建 utils 目录，然后将其放在 utils 目录下：</p>
<p><strong><code>pager.py</code></strong></p>
<pre><code class="py">class PageInfo:
    def __init__(self, current_page, per_page, count_sum, base_url, show_page=11):
        &quot;&quot;&quot;
        :param current_page:当前的页码
        :param per_page:每页显示的数据量
        :param count_sum:总的数据量
        &quot;&quot;&quot;
        try:
            self.current_page = int(current_page)
        except Exception as e:
            self.current_page = 1
        self.per_page = per_page
        self.count_sum = count_sum
        a, b = divmod(count_sum, per_page)
        if b:
            a += 1
        # page_num：所有页码的数量
        self.sum_page_num = a
        self.show_page = show_page
        self.base_url = base_url

    def start(self):
        return (self.current_page - 1) * self.per_page

    def end(self):
        return self.current_page * self.per_page

    def pager(self):
        half = int((self.show_page - 1) / 2)
        # 如果总页数小于11
        if self.sum_page_num &lt; self.show_page:
            begin = 1
            stop = self.sum_page_num + 1
        else:
            if self.current_page &lt;= half:
                begin = 1
                stop = self.show_page + 1
            else:
                if self.current_page + half &gt; self.sum_page_num:
                    begin = self.sum_page_num - self.show_page + 1
                    stop = self.sum_page_num + 1
                else:
                    begin = self.current_page - half
                    stop = self.current_page + half + 1
        page_num_list = []
        index_page = '&lt;li&gt;&lt;a href=&quot;%s?page=1&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;首页&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;' % (self.base_url)
        page_num_list.append(index_page)
        if self.current_page &lt;= 1:
            prev_page = '&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;'
        else:
            prev_page = '&lt;li&gt;&lt;a href=&quot;%s?page=%s&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;' % (
                self.base_url, self.current_page - 1,)

        page_num_list.append(prev_page)
        for i in range(begin, stop):
            if i == self.current_page:
                page_num_list.append(
                    &quot;&lt;li class='active'&gt;&lt;a class='active' href='%s?page=%s'&gt;%s&lt;/a&gt;&lt;/li&gt;&quot; % (self.base_url, i, i))
            else:
                page_num_list.append(&quot;&lt;li&gt;&lt;a class='active' href='%s?page=%s'&gt;%s&lt;/a&gt;&lt;/li&gt;&quot; % (self.base_url, i, i))
        if self.current_page &gt;= self.sum_page_num:
            next_page = '&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;'
        else:
            next_page = '&lt;li&gt;&lt;a href=&quot;%s?page=%s&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;' % (
                self.base_url, self.current_page + 1,)
        page_num_list.append(next_page)

        final_page = '&lt;li&gt;&lt;a href=&quot;%s?page=%s&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;最后一页&lt;/a&gt;&lt;/li&gt;' % (
            self.base_url, self.sum_page_num)
        page_num_list.append(final_page)
        return ''.join(page_num_list)
</code></pre>

<hr>

<h4 id="xss">跨站脚本攻击XSS</h4>
<hr>

<h5 id="1-djangoxss">1. Django处理XSS攻击</h5>
<p>Django 本身默认可以处理 XSS 攻击，例如：</p>
<p><strong><code>views.py</code></strong>:</p>
<pre><code class="py">def test(request):
    ret = '&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;'
    return render(request, 'test.html', {'ret': ret})
</code></pre>

<p><strong><code>test.html</code></strong>:</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{{ ret }}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>并没有解析传入的字符串，当作js脚本来执行。</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2020061419582245.png" /></p>
<p>但是当传入到模板的数据是我们自己的并且是安全的，我们想要告诉系统这是安全的应该如何去做呢！有两种方法，分别是后端标记字符串和前端标记字符串。
<hr></p>
<h5 id="2_6">2. 前端标记字符串</h5>
<p>在模板上写 <strong><code>|safe</code></strong> 的方法可以标记字符串是安全的，可以去解析执行：</p>
<p><strong><code>test.html</code></strong>:</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{{ ret|safe }}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200614200239547.png" />
<hr></p>
<h5 id="3_4">3. 后端标记字符串</h5>
<p>后台把字符串标记成安全的需要在传入模板之前就操作，使用到的是 <strong><code>django.utils.safestring</code></strong> 模块中的 <kbd>mark_safe</kbd> 函数：</p>
<p><strong><code>views.py</code></strong>:</p>
<pre><code class="py">def test(request):
    from django.utils.safestring import mark_safe
    ret = '&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;'
    ret = mark_safe(ret)
    return render(request, 'test.html', {'ret': ret})
</code></pre>

<p><strong><code>test.html</code></strong>:</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{{ ret }}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>与前端标记一样：
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200614200239547.png" />
<hr></p>
<h4 id="csrf">跨站请求伪造CSRF</h4>
<hr>

<h5 id="1_5">1. 基本应用</h5>
<p>Django 中通过生成随机字符串的方式对客户发送提交数据的请求（POST）进行验证，基本原理：客户端向服务端先发送GET请求，服务端会把随机字符串写到请求的页面上，客户端再来提交数据的时候需要带上这个随机字符串，服务端才会处理请求。默认中间件的配置中 CSRF 是开启的状态：</p>
<p><strong><code>settings.py:</code></strong></p>
<pre><code class="py">MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',    # CSRF
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
</code></pre>

<p><strong><code>views.py:</code></strong></p>
<pre><code class="py">def csrf(request):
    if request.method == 'GET':
        return render(request, 'csrf.html')
    else:
        return HttpResponse('ok')
</code></pre>

<p>Django 中的 <strong><code>{% csrf_token %}</code></strong> 就是服务端生成的随机字符串，如果在页面上没有加上它，那么请求的时候就不会带上这个随机字符串：</p>
<p><strong><code>csrf.html:</code></strong></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;text&quot;&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>在提交数据的时候会 403 Forbidden 的错误：
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200615080606759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" /></p>
<p>如果在页面上加上 <strong><code>{% csrf_token %}</code></strong>，客户端在发送 GET 请求后，服务端返回的页面上就会显示这个随机字符串，</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;text&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;csrfmiddlewaretoken&quot; value=&quot;a7brzXos3mDRZlmdWyJcKs72MJ4WtvXaZfa8xWUJq7E3dvNhFrWk3gesKdup3TR2&quot;&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>客户端直接带着这个随机字符串提交提交数据即可，不会再包请求拒绝的问题。
<strong><code>{{ csrf_token }}</code></strong> 会在页面上直接显示这个随机字符串，而 <strong><code>{% csrf_token %}</code></strong> 会生成 input 标签，这是有区别的。
<hr></p>
<h5 id="2_7">2. 全站禁用</h5>
<p>如果全站都不想使用 CSRF 的验证，可以全局禁用处理里 CSRF，只需要在配置文件中的中间件部分注释掉CSRF的过滤，</p>
<pre><code class="py">MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    # 'django.middleware.csrf.CsrfViewMiddleware',  
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
</code></pre>

<p>如果是这样，客户端提交数据请求时不会进行CSRF的处理。
<hr></p>
<h5 id="3_5">3. 局部禁用</h5>
<p>如果不想在某些页面提交请求数据时做CSRF验证，这个时候 <strong><code>django.middleware.csrf.CsrfViewMiddleware</code></strong> 中间件是（全局）开启的状态，那就可以通过 <font>装饰器</font> 的方式单独禁用这个页面发送提交数据请求的CSRF的验证，只需要 <font>在视图函数中加入 csrf_exempt 装饰器</font>：</p>
<p><strong><code>views.py:</code></strong></p>
<pre><code class="py">from django.views.decorators.csrf import csrf_exempt


@csrf_exempt
def csrf(request):
    if request.method == 'GET':
        return render(request, 'csrf.html')
    else:
        return HttpResponse('ok')
</code></pre>

<hr>

<h5 id="4_2">4. 局部使用</h5>
<p>如果在全局禁用的状态下，局部使用 CSRF 验证。需要在视图函数中加上 <font>装饰器</font>，表示在这个视图函数对应的模板中提交数据的请求必须进行 CSRF 验证：</p>
<p><strong><code>views.py:</code></strong></p>
<pre><code class="py">from django.views.decorators.csrf import csrf_protect


@csrf_protect
def csrf(request):
    if request.method == 'GET':
        return render(request, 'csrf.html')
    else:
        return HttpResponse('ok')
</code></pre>

<p>如果在模板中没有加上 <strong><code>{% csrf_token %}</code></strong> 同样是请求被拒绝的：
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200615080606759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" /></p>
<p>加入 csrf 认证后服务端只接收来自本站提交数据的请求，别的站点发送的是不被接收的。所以，csrf 验证是可以防止别的站点发送提交数据的请求到本站。但是，csrf 认证不是完全可以避免的，如过是其它站点获取到了本站的 csrf，带着它去请求本站，服务端也会认为是自己的站点发送的请求，会选择接收请求的。所以，csrf 认证只是在一定程度上保护了站点。
<hr></p>
<h5 id="5-ajaxcsrf">5. AJAX携带CSRF提交数据</h5>
<p>如果 AJAX 不携带 CSRF 字符串提交数据，也会出现 403 Forbidde 报错，所以 <font>AJAX提交数据也是要携带CSRF字符串的</font>。AJAX 携带 CSRF 提交数据的方法有两种，一种是把页面上的 csrf 随机字符串放在 <font>data</font> 中传到后端，另一种是放在 <font>把 csrf 随机字符串放在请求头中</font> 。首先探讨第一种方法：</p>
<p><strong><code>views.py:</code></strong></p>
<pre><code class="py">from django.views.decorators.csrf import csrf_protect

@csrf_protect
def csrf(request):
    if request.method == 'GET':
        return render(request, 'csrf.html')
    else:
        return HttpResponse('ok')
</code></pre>

<p><strong><code>index.html:</code></strong></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form&gt;
    &lt;input type=&quot;text&quot; id=&quot;user&quot;&gt;
    {% csrf_token %}
    &lt;input type=&quot;button&quot; value=&quot;提交&quot; id=&quot;submit&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;script src=&quot;/static/js/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    $(function () {
        submitForm();
    });

    function submitForm() {
        $('#submit').click(function () {
            var user = $('#user').val();
            var csrfmiddlewaretoken = $('input[name=&quot;csrfmiddlewaretoken&quot;]').val()
            $.ajax({
                url: '/index.html/', //可以不写，默认发送到本页面对应的视图函数中
                type: 'post',
                data: {
                    'user': user,
                    'csrfmiddlewaretoken': csrfmiddlewaretoken  //csrfmiddlewaretoken也可以不获取直接拿&quot;{{csrf_token}}&quot;
                },
                success: function (arg) {
                    alert(arg) //ok
                }
            })
        })
    }
&lt;/script&gt;
&lt;/html&gt;
</code></pre>

<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200615122305197.png" />
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200615121557459.png" /></p>
<p>第二种方法，<font>把 cookie 放在请求头中</font>。首先引入插件 <strong><code>jquery.cookie.js</code></strong>，这个插件专门对 cookie 进行操作的，通过 cookie 名可以直接获取 cookie 的值，也还可以设置 cookie：
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2020061512394832.png" /></p>
<p>Django 规定从 <font>浏览器获取的cookie</font> 传入到 Django 中要传到 <font>请求头</font> 中，要使用到 headers：</p>
<p><strong><code>index.html:</code></strong></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form&gt;
    &lt;input type=&quot;text&quot; id=&quot;user&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;提交&quot; id=&quot;submit&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;script src=&quot;/static/js/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/static/js/jquery.cookie.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    $(function () {
        submitForm();
    });

    function submitForm() {
        $('#submit').click(function () {
            var user = $('#user').val();
            var token = $.cookie('csrftoken');
            $.ajax({
                url: '/csrf.html/', //可以不写，默认发送到本页面对应的视图函数中
                type: 'post',
                headers:{'X-CSRFToken':token},
                data: {
                    'user': user
                },
                success: function (arg) {
                    alert(arg) //ok
                }
            })
        })
    }
&lt;/script&gt;
&lt;/html&gt;
</code></pre>

<hr>

<h4 id="session">Session基本使用</h4>
<hr>

<h5 id="1-session">1. Session简介</h5>
<p>客户端向服务端发送请求获取登录页面，服务端返回给客户端登录页面。客户端向服务器端发送登录系统的请求，如果登录成功，服务端会生成一段随机字符串，会把随机字符串和客户端数据对应起来保存在服务端并返回给客户端。每一个客户端登录成功后，服务端都会保存随机字符串和数据。当客户端带着服务端之前返回的随机字符串和数据(被写在浏览器的 Cookie 中)再次向服务端请求数据时，在 Session 没有失效的情况下，就不需要验证客户端的状态。Session 本质是键值对：</p>
<pre><code class="py">{
    'zx7a4imi2v5dvfrda1vlw3lkoiao6ubj':{'id':1,'name':'erics'},
}
</code></pre>

<p>Session<font>是保存在服务器端的数据，本质上是键值对</font>。一般用于 Web 网站的时候保持与用户之间的会话，即记录用户的的登录状态，登录之后不要求再次登录。它的优点是敏感信息不会直接给客户端。Session 的应用依赖 Cookie，Session 需要通过 Cookie 写给客户端浏览器。</p>
<p>Cookie<font>是保存在客户端上的键值对!</font>
<hr></p>
<h5 id="2-session">2. 基于Session的用户登录</h5>
<p>Django 内置 Session 操作( Flask 也内置 Session )，所以可以直接使用。下面基于 Session 来完成用户登录：</p>
<p><strong><code>views.py</code></strong></p>
<pre><code class="py">from django.shortcuts import render, HttpResponse, redirect
from app01 import models
from django.views import View
from utils.md5 import md5

class Login(View):
    def get(self, request):
        return render(request, 'login.html')

    def post(self, request):
        name = request.POST.get('name')
        pwd = request.POST.get('pwd')
        obj = models.User.objects.all().filter(name=name, pwd=md5(pwd)).first()
        if obj:
            &quot;&quot;&quot;
            1.生成随机字符串
            2.通过cookie发送给客户端
            3.服务端保存[随机字符创1:['xx':xx,'xxx':xxx,...]](Session)
            &quot;&quot;&quot;
            request.session['name'] = name
            return redirect('/index.html/')
        return HttpResponse()

def index(request):
    &quot;&quot;&quot;
    1.获取客户端cookie中的字符串
    2.去session中查找有没有这个字符串
    3.在session对应key的value中查看有没有name
    &quot;&quot;&quot;
    v = request.session.get('name')
    if v:
        return HttpResponse('%s登录成功！' % (v))
    else:
        return redirect('/login.html/')
</code></pre>

<p><strong><code>md5.py:</code></strong></p>
<pre><code class="py">import hashlib

SALT = b'erics'

# 自定义MD5函数
def md5(pwd):
    obj = hashlib.md5(SALT)
    # pwd是字符串，需要将其转换成字节
    obj.update(pwd.encode('utf-8'))
    # 返回密文
    return obj.hexdigest()
</code></pre>

<p><strong><code>login.html:</code></strong></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;登录&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/bootstrap.min.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot; style=&quot;margin-top: 10px&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-md-4 col-md-offset-4&quot;&gt;
            &lt;div class=&quot;panel panel-primary&quot;&gt;
                &lt;div class=&quot;panel-heading&quot;&gt;
                    登录
                &lt;/div&gt;
                &lt;div class=&quot;panel-body&quot;&gt;
                    &lt;form action=&quot;/login.html/&quot; method=&quot;POST&quot; name=&quot;loginForm&quot;&gt;
                        &lt;div class=&quot;form-group&quot;&gt;
                            &lt;label for=&quot;name&quot;&gt;用户名&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;name&quot;
                                                                 placeholder=&quot;请输入用户名&quot;&gt;
                        &lt;/div&gt;
                        &lt;div class=&quot;form-group&quot;&gt;
                            &lt;label for=&quot;&quot;&gt;密码&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; name=&quot;pwd&quot;
                                                            placeholder=&quot;请输入密码&quot;&gt;
                            &lt;div style=&quot;color: red;font-weight: bold&quot;&gt;{{ msg }}&lt;/div&gt;
                        &lt;/div&gt;
                        {% csrf_token %}
                        &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;登录&lt;/button&gt;
                    &lt;/form&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>登录页面：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200616085128265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" /></p>
<p>用户登录之后，服务端把Session保存在数据库中的 <strong><code>django_session</code></strong> 表中，session_data也就是随机字符串对应的键值被内部进行了加密：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200616085446540.png" /></p>
<p>登录成功：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200616085217430.png" /></p>
<p>浏览器上查看有没有这样的cookie：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200616090412528.png" />
<hr></p>
<h5 id="3-session">3. Session的配置</h5>
<pre><code class="py">def test(request):
    pass
    &quot;&quot;&quot;
    1.获取/设置/删除session中的数据
    &quot;&quot;&quot;
    # 获取session中的数据，如果k1不存在则报错
    request.session['k1']
    # 获取session中的数据，如果k1不存在则获取到的是None
    request.session.get('k1', None)
    # 设置session中的数据
    request.session['k1'] = 'erics'
    # 设置session中的数据，存在则不设置
    request.session.setdefault('k1', 'erics')
    # 删除session中的数据
    del request.session['k1']
    &quot;&quot;&quot;
    2.获取键/值/键值对
    &quot;&quot;&quot;
    request.session.keys()
    request.session.values()
    request.session.items()
    &quot;&quot;&quot;
    3.获取用户session的字符串
    &quot;&quot;&quot;
    request.session.session_key
    &quot;&quot;&quot;
    4.将所有session失效日期小于当前日期的数据删除
    &quot;&quot;&quot;
    request.session.clear_expired()
    &quot;&quot;&quot;
    5.检查用户session的随机字符串在数据库中是否存在
    &quot;&quot;&quot;
    request.session.exists(request.session.session_key)
    &quot;&quot;&quot;
    6.删除当前用户的所有session数据(session_id和session_data)，会话没有了下次需要重新登录
    &quot;&quot;&quot;
    request.session.delete(request.session.session_key)
    &quot;&quot;&quot;
    7.设置超时时间(在浏览器cookie和数据库中都设置)，如果value是整数，表示多少s之后失效；如果是datetime或timedelta，在这个时间后失效；
    value=0表示关闭浏览器失效(浏览器关闭，不是Web页面关闭)；value=None表示依赖全局session失效策略
    &quot;&quot;&quot;
    request.session.set_expiry(value=None)
</code></pre>

<p>如果使用 Django 默认的 session 登录后，浏览器上的 session 默认生效时间是2周，被存放在浏览器的 cookie 中，2周之后 cookie 会被删除。但是数据库中的 session 不会被删除，只能手动删除。可以将所有 session 失效日期小于当前日期的数据删除。session 的配置可以写在 <strong><code>settings.py</code></strong> 文件中：</p>
<pre><code class="py">&quot;&quot;&quot;
以下为默认的配置，如果写了会把默认配置覆盖(优先级高)
&quot;&quot;&quot;
SESSION_COOKIE_NAME = 'session_id'  # session的cookie保存在浏览器上名字,sessionid=随机字符串
SESSION_COOKIE_PATH = '/'  # 在所有的url上都生效
SESSION_COOKIE_DOMAIN = None  # session的cookie保存的域名
SESSION_COOKIE_SECURE = False  # 是否https传输cookie
SESSION_COOKIE_HTTPONLY = True  # 是否session的cookie只支持http传输
SESSION_COOKIE_AGE = 1209600  # session的cookie失效日期(2周)
SESSION_EXPIRE_AT_BROWSER_CLOSE = False  # 是否关闭浏览器使session的cookie过期
SESSION_SAVE_EVERY_REQUEST = False  # 是否每次请求都保存session(如设置了30分钟失效，如果是True，30min之内操作从最后一次操作开始计算30分钟后失效)
</code></pre>

<hr>

<h5 id="4-session">4. Session数据源配置</h5>
<p>Session的配置都要放在settings.py文件中！</p>
<p>放在数据库中：</p>
<pre><code class="py">SESSION_ENGINE = 'django.contrib.session.backends.db'  # 默认
</code></pre>

<p>放在文件中：</p>
<pre><code class="py">SESSION_ENGINE = 'django.contrib.session.backends.file'
SESSION_FILE_PATH = None  # 没有设置文件路径，Django会使用tempfile模块获取一个临时地址tempfile.gettempdir()
</code></pre>

<p>放在缓存中：</p>
<pre><code class="py">SESSION_ENGINE = 'django.contrib.session.backends.cache'
SESSION_CACHE_ALIAS = 'default'  # 使用缓存别名（默认内存缓存）,default可以代之缓存服务器的IP和Port
</code></pre>

<p>放在数据库和缓存中：</p>
<pre><code class="py">SESSION_ENGINE = 'django.contrib.session.backends.cache_db'
</code></pre>

<p>放在cookie中：</p>
<pre><code class="py">SESSION_ENGINE = 'django.contrib.session.backends.signed_cookies'
</code></pre>

<p><font>推荐使用数据和缓存来存放Session！</font>
<hr></p>
<h4 id="wsgi">WSGI</h4>
<hr>

<h5 id="1-wsgi">1. WSGI</h5>
<p>WSGI 即 Web 服务网关接口，这是一种协议。uwsgi 和 wsgiref 都是基于这个协议。Django 没有自己的 socket，<font>默认使用的是 wsgiref</font>。wsgiref 由于性能原因，一般用于本地测试环境，uwsgi 支持并发的一些设置可用于生产环境。
<hr></p>
<h5 id="2-django_2">2. Django请求的生命周期</h5>
<p>socket 的作用是接收请求和响应请求。当用户向 socket 发送请求数据后，socket 还需要对请求数据进行解析，根据请求数据来响应不同的内容。Django 做的就是解析请求数据（需要从 socket 中获取请求相关信息），找到对应的响应内容（产出字符串），然后返回给 socket，socket 再发送响应数据给用户。Django 不关心 socket 接发数据，只关心 <font>从 socket 那里获取到请求数据并处理和返回请求数据给 socket</font>。</p>
<pre><code class="py">def RunServer(environ, start_response):
    &quot;&quot;&quot;
    :param environ: 请求相关的所有操作
    :param start_response:socket给Django的容器，Django最后要把容器给socket，可以用来方请求头
    :return:
    &quot;&quot;&quot;
    # Django框架开始
    # 中间件
    # 路由系统
    # 视图函数
    # 数据库
    # 模板引擎的渲染
    # 最后把响应头+响应体通过socket返回给用户
    start_response('200 OK', [('Content-Type', 'text/html')])
    return [bytes('&lt;h1&gt;!!!&lt;/h1&gt;', encoding='utf-8')]


if __name__ == '__main__':
    &quot;&quot;&quot;
    下面两句代码的操作是：创建socket服务端和等待客户端连接
    &quot;&quot;&quot;
    httpd = make_server('localhost', 8000, RunServer)
    httpd.serve_forever()
</code></pre>

<p>Django 部分源码，Django 请求处理的入口点：
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200617212524672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" />
<hr></p>
<p>Django 请求的生命周期流程：用户-&gt;WSGI-&gt;中间件-&gt;视图函数(数据库和模板进行渲染)-&gt;中间件-&gt;WSGI-&gt;用户，中间件和视图函数部分属于 Django。
<hr></p>
<h4 id="_6">中间件</h4>
<hr>

<h5 id="1_6">1. 中间件执行流程</h5>
<p>Django 1.10之前，请求到达第一个中间件，会找到最后一个中间件的 process_response 返回：
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200618005438431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" /></p>
<p>而Django 1.10之后，会找到自己的 process_response 返回：
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200618005323503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" /></p>
<p><font>中间件是有序执行的！</font>
<hr></p>
<h5 id="2_8">2. 中间件原理浅析</h5>
<p>中间件是类，首先查看 Django 源码中的中间件：
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200618011158584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" /></p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200618011204639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" /></p>
<p>所以，我们写的中间件也要继承 <strong><code>MiddlewareMixin</code></strong> 类，这里把中间件类写在 <strong><code>middleware.py</code></strong>，并放置在与 <strong><code>manage.py</code></strong> 同级目录下：</p>
<p><strong><code>middleware.py:</code></strong></p>
<pre><code class="py">from django.utils.deprecation import MiddlewareMixin

class M1(MiddlewareMixin):
    def process_request(self, request):
        print('m1.process_request')

    def process_response(self, request, response):
        print('m1.process_response')
        return response

class M2(MiddlewareMixin):
    def process_request(self, request):
        print('m2.process_request')

    def process_response(self, request, response):
        print('m2.process_response')
        return response
&quot;&quot;&quot;
m1.process_request
m2.process_request
test
m2.process_response
m1.process_response
&quot;&quot;&quot;
</code></pre>

<p>还要在配置文件 <strong><code>settings.py</code></strong> 中注册中间件：</p>
<pre><code class="py">MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'middleware.M1',
    'middleware.M2'
]
</code></pre>

<p>可以看到先执行 <kbd>process_request</kbd> 再执行 <kbd>process_response</kbd>。还有个 <kbd>process_view</kbd> 方法：</p>
<pre><code class="py">from django.utils.deprecation import MiddlewareMixin

class M1(MiddlewareMixin):
    def process_request(self, request):
        print('m1.process_request')

    def process_view(self, request, callback, callback_args, callback_kwargs):
        print('m1.process_view')
        # return callback(*callback_args, **callback_kwargs)

    def process_response(self, request, response):
        print('m1.process_response')
        return response

class M2(MiddlewareMixin):
    def process_request(self, request):
        print('m2.process_request')

    def process_view(self, request, callback, callback_args, callback_kwargs):
        print('m2.process_view')
        # return callback(*callback_args, **callback_kwargs)

    def process_response(self, request, response):
        print('m2.process_response')
        return response

&quot;&quot;&quot;
m1.process_request
m2.process_request
m1.process_view
m2.process_view
test
m2.process_response
m1.process_response
&quot;&quot;&quot;
</code></pre>

<p>process_request 有返回值会直接执行自己的 process_response 。如果执行的是 process_view 有返回值，会跳过下一个中间件的 process_view，执行视图函数(<font>这里是自动调用的</font>)。接下来，不是执行自己的 process_response 返回给用户，而是 <font>最开始</font> 的 process_response（<font>把所有的 process_response 都执行一遍</font>）：</p>
<pre><code class="py">from django.utils.deprecation import MiddlewareMixin


class M1(MiddlewareMixin):
    def process_request(self, request):
        print('m1.process_request')

    def process_view(self, request, callback, callback_args, callback_kwargs):
        # print(callback, callback_args, callback_kwargs) #&lt;function test at 0x7fd39b986040&gt; () {}
        print('m1.process_view')
        response = callback(request, *callback_args, **callback_kwargs)
        return response

    def process_response(self, request, response):
        print('m1.process_response')
        return response


class M2(MiddlewareMixin):
    def process_request(self, request):
        print('m2.process_request')

    def process_view(self, request, callback, callback_args, callback_kwargs):
        print('m2.process_view')

    def process_response(self, request, response):
        print('m2.process_response')
        return response

&quot;&quot;&quot;
m1.process_request
m2.process_request
m1.process_view
test
m2.process_response
m1.process_response
&quot;&quot;&quot;
</code></pre>

<p>中间件的类中还有 <kbd>process_exception</kbd> 方法，这是关于异常的方法。为了进行测试首先在视图函数中使代码产生异常：</p>
<pre><code class="py">def test(request):
    print('test')
    a = int('erics')
    return HttpResponse()
</code></pre>

<p>通过下面的代码测试发现，请求经过所有的 process_request、process_view 到达视图函数，没有错误的情况下会执行 process_response，出现错误会执行 process_exception 在执行 process_response：</p>
<pre><code class="py">from django.utils.deprecation import MiddlewareMixin

class M1(MiddlewareMixin):
    def process_request(self, request):
        print('m1.process_request')

    def process_view(self, request, callback, callback_args, callback_kwargs):
        # print(callback, callback_args, callback_kwargs) #&lt;function test at 0x7fd39b986040&gt; () {}
        print('m1.process_view')
        # response = callback(request, *callback_args, **callback_kwargs)
        # return response
    #
    def process_response(self, request, response):
        print('m1.process_response')
        return response

    def process_exception(self, request, exception):
        print('m1.process_exception')


class M2(MiddlewareMixin):
    def process_request(self, request):
        print('m2.process_request')

    def process_view(self, request, callback, callback_args, callback_kwargs):
        print('m2.process_view')

    def process_response(self, request, response):
        print('m2.process_response')
        return response

    def process_exception(self, request, exception):
        print('m2.process_exception')

&quot;&quot;&quot;
m1.process_request
m2.process_request
m1.process_view
m2.process_view
test
m2.process_exception
m1.process_exception
m2.process_response
m1.process_response
&quot;&quot;&quot;
</code></pre>

<p>在 process_exception 使用 HttpResponse 函数返回异常，可以看这个时候中间件方法的执行顺序：</p>
<pre><code class="py">from django.utils.deprecation import MiddlewareMixin
from django.shortcuts import HttpResponse

class M1(MiddlewareMixin):
    def process_request(self, request):
        print('m1.process_request')

    def process_view(self, request, callback, callback_args, callback_kwargs):
        # print(callback, callback_args, callback_kwargs) #&lt;function test at 0x7fd39b986040&gt; () {}
        print('m1.process_view')
        # response = callback(request, *callback_args, **callback_kwargs)
        # return response
    #
    def process_response(self, request, response):
        print('m1.process_response')
        return response

    def process_exception(self, request, exception):
        print('m1.process_exception')

class M2(MiddlewareMixin):
    def process_request(self, request):
        print('m2.process_request')

    def process_view(self, request, callback, callback_args, callback_kwargs):
        print('m2.process_view')

    def process_response(self, request, response):
        print('m2.process_response')
        return response

    def process_exception(self, request, exception):
        # print('m2.process_exception')
        return HttpResponse('出现异常！')

&quot;&quot;&quot;
m1.process_request
m2.process_request
m1.process_view
m2.process_view
test
m2.process_response
m1.process_response
&quot;&quot;&quot;
</code></pre>

<p>异常被 M2 的 process_exception 处理了，跳过 M1 的 process_exception，直接执行 process_response。页面也不没有报错了：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200618023429223.png" /></p>
<p>中间件中还有 process_template_response 方法，但是这个方法在视图函数的返回值中有 render 方法才会执行，没有 render 方法不会被执行，所以这里修改视图函数：</p>
<pre><code class="py">class Foo:
    def __init__(self, req):
        self.req = req

    def render(self):
        return HttpResponse()

def test(request):
    obj = Foo(request)
    return obj
</code></pre>

<p>接下来可以看到 process_template_response 方法被执行，</p>
<pre><code class="py">from django.utils.deprecation import MiddlewareMixin
from django.shortcuts import HttpResponse

class M1(MiddlewareMixin):
    def process_request(self, request):
        print('m1.process_request')

    def process_view(self, request, callback, callback_args, callback_kwargs):
        print('m1.process_view')

    def process_response(self, request, response):
        print('m1.process_response')
        return response

    def process_exception(self, request, exception):
        print('m1.process_exception')

    def process_template_response(self, request, response):
        &quot;&quot;&quot;
        视图函数的返回值中有render方法才会执行
        :param request:
        :param response:
        :return:
        &quot;&quot;&quot;
        print('m1.process_template_response')
        return response

class M2(MiddlewareMixin):
    def process_request(self, request):
        print('m2.process_request')

    def process_view(self, request, callback, callback_args, callback_kwargs):
        print('m2.process_view')

    def process_response(self, request, response):
        print('m2.process_response')
        return response

    def process_exception(self, request, exception):
        return HttpResponse('出现异常！')

    def process_template_response(self, request, response):
        print('m2.process_template_response')
        return response

&quot;&quot;&quot;
m1.process_request
m2.process_request
m1.process_view
m2.process_view
m2.process_template_response
m1.process_template_response
m2.process_response
m1.process_response
&quot;&quot;&quot;
</code></pre>

<p>process_template_response 方法的使用，可以帮助我们把一些可以复用的功能组件拆分出来，如 JSON 序列化：</p>
<pre><code class="py">class Foo:
    def __init__(self, req, status, msg):
        self.req = req
        self.status = status
        self.msg = msg

    def render(self):
        import json
        ret = {
            'status': self.status,
            'msg': self.msg
        }
        return HttpResponse(json.dumps(ret))

def test(request):
    return Foo(request, True, '错误信息！')
</code></pre>

<p>在视图函数中打造功能，改造另外一个对象，让这个对象把我们的数据封装起来：</p>
<pre><code class="py">class JsonResponse:
    &quot;&quot;&quot;
    内部帮助我们序列化，
    &quot;&quot;&quot;
    def __init__(self, req, status, msg):
        self.req = req
        self.status = status
        self.msg = msg

    def render(self):
        import json
        ret = {
            'status': self.status,
            'msg': self.msg
        }
        return HttpResponse(json.dumps(ret))


def test(request):
    return JsonResponse(request, True, '错误信息！')
</code></pre>

<p><font>视图函数返回的对象且对象中有 render 方法才会执行 process_template_response方法。</font>
<hr></p>
<h5 id="3_6">3. 中间件的应用</h5>
<p>中间件可以对 <font>所有请求或一部分请求做批量处理</font>。使用缓存时，需要对 <font>所有请求进行判断</font>，缓存中如果有就把缓存中的数据返回，没有就执行视图函数。对所有的请求进行判断就需要使用到中间件。
<hr></p>
<h5 id="4_3">4. 中间件解决跨域问题</h5>
<p>由于浏览器同源策略的限制（同一主机不同端口之间），会产生客户端向服务端请求存在跨域的问题，如向服务端发送获取数据的请求，客户端：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;button @click=&quot;getUser&quot;&gt;获取用户信息&lt;/button&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(item,index) in users&quot;&gt;{{item}}&lt;/li&gt;
        &lt;li v-for=&quot;(item,index) in users&quot;&gt;{{item.id}}&lt;/li&gt;
        &lt;li v-for=&quot;(item,index) in users&quot;&gt;{{item.name}}&lt;/li&gt;
        &lt;li v-for=&quot;(item,index) in users&quot;&gt;{{item.register_date}}&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/axios.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    new Vue({
        el: '#app',
        data: {
            apiDomain: 'http://localhost:8000/api/v1',
            users: []
        },
        methods: {
            getUser() {
                let self = this
                axios.get(`${this.apiDomain}/user/`).then(function (response) {
                    self.users = response.data.data
                    console.log(response)
                }).catch(function (error) {
                    console.log(error)
                })
            }
        }
    });
&lt;/script&gt;
&lt;/html&gt;
</code></pre>

<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200621214743591.png" /></p>
<p>服务端：</p>
<pre><code class="py">from rest_framework import views, serializers, response
from .. import models

class UserSerializer(serializers.ModelSerializer):
    name = serializers.CharField(max_length=5, error_messages={'max_length': '字段太长！'})
    register_date = serializers.DateTimeField(format='%Y-%m-%d %X')

    class Meta:
        model = models.User
        fields = ('name', 'register_date', 'id')

class User(views.APIView):
    def get(self, request):
        qs = models.User.objects.all().first()
        serializer = UserSerializer(qs, many=False)
        return response.Response({
            'status': 0,
            'data': serializer.data
        })
</code></pre>

<p>当点击获取数据的按钮后，报错：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2020062121491146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" /></p>
<p>这时候可以在 Django 中写中间件，通过修改 <font>response 的属性允许这个域的请求</font> 来解决：</p>
<pre><code class="py">from django.utils.deprecation import MiddlewareMixin

class M1(MiddlewareMixin):
    def process_response(self, request, response):
        response['Access-Control-Allow-Origin'] = '*'
        return response
</code></pre>

<p>记得需要在配置文件中配置这个中间件：</p>
<pre><code class="py">MIDDLEWARE = [
    ...
    'app.middle.M1'
]
</code></pre>

<p>这个时候就可以成功获取数据：
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200621223508390.png" /></p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200621221349584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" />
再看下提交数据的请求：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;button @click=&quot;getUser&quot;&gt;获取用户信息&lt;/button&gt;
    &lt;button @click=&quot;createUser&quot;&gt;创建用户信息&lt;/button&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(item,index) in users&quot;&gt;{{item}}&lt;/li&gt;
        &lt;li v-for=&quot;(item,index) in users&quot;&gt;{{item.id}}&lt;/li&gt;
        &lt;li v-for=&quot;(item,index) in users&quot;&gt;{{item.name}}&lt;/li&gt;
        &lt;li v-for=&quot;(item,index) in users&quot;&gt;{{item.register_date}}&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/axios.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    new Vue({
        el: '#app',
        data: {
            apiDomain: 'http://localhost:8000/api/v1',
            users: []
        },
        methods: {
            getUser() {
                let self = this
                axios.get(`${this.apiDomain}/user/`).then(function (response) {
                    self.users = response.data.data
                    console.log(response)
                }).catch(function (error) {
                    console.log(error)
                })
            },
            createUser() {
                let self = this
                axios.post(`${this.apiDomain}/user/`, {&quot;name&quot;: 'Thanlon'}).then(function (response) {
                    console.log(response)
                }).catch(function (error) {
                    console.log(error)
                })
            }
        }
    });
&lt;/script&gt;
&lt;/html&gt;
</code></pre>

<p>发送 POST 请求提交数据的时候，客户端报错竟然也报跨域问题。根据报错提示，这是不允许请求头引起的，所以需要配置允许的请求头 Access-Control-Allow-Headers：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2020062122424084.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" /></p>
<p>并且服务端报错：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200621224306606.png" />
这是因为一般跨域会出现预检请求，浏览器会认为这是一次复杂的请求，会先发一个请求做预检。预检请求响应的状态是 200 的时候才会发真正的请求。所以，还需要在 <font>中间件中设置允许的方法</font>：</p>
<pre><code class="py">from django.utils.deprecation import MiddlewareMixin

class M1(MiddlewareMixin):
    def process_response(self, request, response):
        # 允许请求的域
        response['Access-Control-Allow-Origin'] = '*'
        # 允许请求的请求头
        response['Access-Control-Allow-Headers'] = '*'
        # 允许请求的方法，适用*是允许所有，还可以指定。需要用都好隔开,例如'OPTIONS,GET,POST',实测发现这里不需要也是可以的
        # response['Access-Control-Allow-Methods'] = 'OPTIONS'
        return response
</code></pre>

<hr>

<h4 id="form">Form组件</h4>
<hr>

<h5 id="1-form">1. Form组件的功能</h5>
<p>对用户提交表单数据进行校验、保留上次输入内容。
<hr></p>
<h5 id="2_9">2. 数据校验</h5>
<p>Form组件对Form表单的方式提交的数据进行校验：</p>
<p><strong><code>login.html:</code></strong></p>
<pre><code class="py">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;登录&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/bootstrap.min.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot; style=&quot;margin-top: 10px&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-md-4 col-md-offset-4&quot;&gt;
            &lt;div class=&quot;panel panel-primary&quot;&gt;
                &lt;div class=&quot;panel-heading&quot;&gt;
                    登录
                &lt;/div&gt;
                &lt;div class=&quot;panel-body&quot;&gt;
                    &lt;form action=&quot;/login.html/&quot; method=&quot;POST&quot; name=&quot;loginForm&quot;&gt;
                        &lt;div class=&quot;form-group&quot;&gt;
                            &lt;label for=&quot;name&quot;&gt;用户名&lt;/label&gt;
                            &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;name&quot; placeholder=&quot;请输入用户名&quot;&gt;
                            &lt;div style=&quot;color: red;font-weight: bold&quot;&gt;{{ obj.errors.name.0 }}&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class=&quot;form-group&quot;&gt;
                            &lt;label for=&quot;&quot;&gt;密码&lt;/label&gt;
                            &lt;input type=&quot;password&quot; class=&quot;form-control&quot; name=&quot;pwd&quot; placeholder=&quot;请输入密码&quot;&gt;
                            &lt;div style=&quot;color: red;font-weight: bold&quot;&gt;{{ obj.errors.pwd.0 }}&lt;/div&gt;
                        &lt;/div&gt;
                        {% csrf_token %}
                        &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;登录&lt;/button&gt;
                    &lt;/form&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200622102003133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" /></p>
<pre><code class="py">class LoginForm(Form):
    name = fields.CharField(
        required=True,
        min_length=6,
        max_length=20,
        error_messages={
            'required': '用户名不能为空！',
            'min_length': '用户名长度不能小于6！',
            'max_length': '用户名长度不能大于20！'
        }
    )
    pwd = fields.CharField(
        required=True,
        min_length=6,
        max_length=20,
        error_messages={
            'required': '密码不能为空！',
            'min_length': '密码长度不能小于6！',
            'max_length': '密码长度不能大于20！'
        }
    )

def login(request):
    if request.method == 'GET':
        return render(request, 'login.html')
    else:
        obj = LoginForm(request.POST)
        &quot;&quot;&quot;
        1、LoginForm实例化时
        self.field={'name':正则表达式,'pwd':正则表达式}
        2、循环self.field
        for k,v in self.field.items():
            input_value = request.POST.get(k)
            正则表达式和input_value进行匹配
        &quot;&quot;&quot;
        if obj.is_valid():
            # 校验通过的数据
            print(obj.cleaned_data)
        else:
            print(obj.errors, type(obj.errors))  # &lt;class 'django.forms.utils.ErrorDict'&gt;
            &quot;&quot;&quot;
            &lt;ul class=&quot;errorlist&quot;&gt;
                &lt;li&gt;name
                    &lt;ul class=&quot;errorlist&quot;&gt;
                        &lt;li&gt;用户名不能为空&lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/li&gt;
                &lt;li&gt;pwd
                    &lt;ul class=&quot;errorlist&quot;&gt;
                        &lt;li&gt;用户名不能为空&lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
            &quot;&quot;&quot;
        return render(request, 'login.html', {'obj': obj})
</code></pre>

<p>上面是 Form 组件校验以 Form 表单的方式的提交数据，下面是以 AJAX 的方式提交数据：</p>
<p><strong><code>login.html:</code></strong></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;登录&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;../static/css/bootstrap.min.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot; style=&quot;margin-top: 10px&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-md-4 col-md-offset-4&quot;&gt;
            &lt;div class=&quot;panel panel-primary&quot;&gt;
                &lt;div class=&quot;panel-heading&quot;&gt;
                    登录
                &lt;/div&gt;
                &lt;div class=&quot;panel-body&quot;&gt;
                    &lt;form id=&quot;form&quot; action=&quot;&quot; method=&quot;POST&quot; name=&quot;loginForm&quot; novalidate&gt;
                        &lt;div class=&quot;form-group&quot;&gt;
                            &lt;label for=&quot;name&quot;&gt;用户名&lt;/label&gt;
                            &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;name&quot; placeholder=&quot;请输入用户名&quot;&gt;
                            &lt;div style=&quot;color: red;font-weight: bold&quot;&gt;{{ obj.errors.name.0 }}&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class=&quot;form-group&quot;&gt;
                            &lt;label for=&quot;&quot;&gt;密码&lt;/label&gt;
                            &lt;input type=&quot;password&quot; class=&quot;form-control&quot; name=&quot;pwd&quot; placeholder=&quot;请输入密码&quot;&gt;
                            &lt;div style=&quot;color: red;font-weight: bold&quot;&gt;{{ obj.errors.pwd.0 }}&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class=&quot;form-group&quot;&gt;
                            &lt;label for=&quot;&quot;&gt;邮箱&lt;/label&gt;
                            &lt;input type=&quot;email&quot; class=&quot;form-control&quot; name=&quot;email&quot; placeholder=&quot;请输入密码&quot;&gt;
                            &lt;div style=&quot;color: red;font-weight: bold&quot;&gt;{{ obj.errors.email.0 }}&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class=&quot;form-group&quot;&gt;
                            &lt;label for=&quot;&quot;&gt;手机号&lt;/label&gt;
                            &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;phone&quot; placeholder=&quot;请输入密码&quot;&gt;
                            &lt;div style=&quot;color: red;font-weight: bold&quot;&gt;{{ obj.errors.phone.0 }}&lt;/div&gt;
                        &lt;/div&gt;
                        {% csrf_token %}
                        &lt;button id=&quot;loginBtn&quot; type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;登录&lt;/button&gt;
                    &lt;/form&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;../static/js/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    $(function () {
        ajaxLogin();
    })

    function ajaxLogin() {
        $('#loginBtn').click(function () {
            var formData = $('#form').serialize();//会忽略字段左右的空格
            console.log(formData)//name=thanlon&amp;pwd=123456&amp;email=thanlon@sina.com&amp;phone=18523332005&amp;csrfmiddlewaretoken=xxx
            $.ajax({
                url: '/login.html/',
                type: 'post',
                data: formData,
                dataType: 'json',
                success: function (arg) {
                    console.log(arg);//{&quot;status&quot;: 0, &quot;msg&quot;: null}
                    if (arg.status) {
                        //location.href = 'https://www.baidu.com'
                    } else {
                        //清除之前的错误提示信息
                        $('.clearTag').remove();
                        console.log(arg.msg)//对象类型
                        $.each(arg.msg, function (index, value) {
                            /**
                             * alert(index);//错误字段，pwd
                             * alert(value);//错误消息,如This field is required.
                             * alert(typeof (index)) //string
                             * alert(typeof (value))//object
                             * alert(value[0])
                             */
                            var tag = document.createElement('span');
                            tag.innerHTML = value[0];
                            tag.className = 'clearTag';
                            $('#form').find('input[name=&quot;' + index + '&quot;]').after(tag);
                        })
                    }
                }
            })
        })
    }
&lt;/script&gt;
&lt;/html&gt;
</code></pre>

<p><strong><code>views.py:</code></strong></p>
<pre><code class="py">from django.forms import Form, fields
from django.shortcuts import render, HttpResponse
from app01 import models
import json

class LoginForm(Form):
    name = fields.CharField()
    pwd = fields.CharField()
    email = fields.EmailField()
    phone = fields.RegexField('185\d+')

def ajax_login(request):
    if request.method=='GET':
        return render(request,'login.html')
    ret = {'status': True, 'msg': None}
    print(type(json.dumps(ret)))  # &lt;class 'str'&gt;
    obj = LoginForm(request.POST)
    if obj.is_valid():
        print(obj.cleaned_data)#{'name': 'thanlon', 'pwd': '123456', 'email': 'thanlon@sina.com', 'phone': '18523332005'}
    else:
        print(obj.errors)  # obj.errors是对象
        ret['status'] = False
        ret['msg'] = obj.errors
    return HttpResponse(json.dumps(ret))  # &lt;class 'str'&gt;
</code></pre>

<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200622164034109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" /></p>
<p><font>AJAX 仅用来验证功能，Form 可以验证功能也可以生成 HTML 标签</font>。
<hr></p>
<h5 id="3_7">3. 常用字段和参数</h5>
<pre><code class="py">Field：
    required = True,  # 是否允许为空
    label = None,  # 用于生成Label标签
    initial = None,  # 初始值
    help_text = '',  # 帮助信息（在标签旁边显示）
    error_messages = {},  # 错误信息{'invalid':'格式错误'}
    show_hidden_initial = None,  # 是否在当前插件后面再加上一个隐藏的且具有默认值的插件（可用于检验两次输入是否一致）
    validators = [],  # 自定义验证规则
    localize = False,  # 是否支持本地化
    disabled = False,  # 是否可以编辑
    label_suffix = None,  # Label内容后缀
    widget = None,  # HTML插件
</code></pre>

<p>CharField 类和 IntegerField 类都继承 Field 类，但是除了具有 Field 中的所有属性之外还有其它属性：</p>
<pre><code class="py">CharField(Field)：
    min_length = None,
    max_length = None,
    strip = True,  # 是否移除空白

IntegerField(Field):
    min_length = None,
    max_length = None,

DecimalField(IntegerField):
    max_value=None,  # 最大值
    min_value=None,  # 最小值
    max_digits=None,  # 总长度

BaseTemporalField(Field)
    input_formats=None,  # 时间格式化

BaseTemporalField(Field)
    input_formats=None,  # 时间格式化

DateField(BaseTemporalField): # 格式：2020-10-12
TimeField(BaseTemporalField): # 格式：12:50
DateTimeField(BaseTemporalField): # 格式：2020-10-12 12:50

DurationField(Field): # 时间间隔：%d %H:%M:%S.%f

RegexField(CharField):
    regex='185\d+',
    max_length=None,
    min_length=None,
    error_messages={}

EmailField(CharField)
URLField(CharField)
SlugField(CharField)
GenericIPAddressField(CharField)
</code></pre>

<hr>

<h5 id="4_4">4. 保留上次输入内容</h5>
<p>Form 表单的方式提交数据，页面会刷新会失去提交的内容。AJAX 方式提交时页面不刷新，上次输入内容自动保存。使用 Form 表单提交数据保存上次输入的内容也是可以实现的，需要应用到 Form 组件提供的第二个功能生成HTML标签。只需要在 input 框中加入验证通过的数据 <strong><code>obj.cleaned_data</code></strong>：</p>
<p><strong><code>views.py:</code></strong></p>
<pre><code class="py">class LoginForm(Form):
    name = fields.CharField(
        label='用户名',
    )
    pwd = fields.CharField(
        label='密码',
    )
    email = fields.EmailField(
        label='邮箱'
    )
    phone = fields.RegexField(
        label='手机号',
        regex='185\d+',
    )

def ajax_login(request):
    if request.method == 'GET':
        obj = LoginForm()
        return render(request, 'login.html',{'obj': obj})
    else:
        obj = LoginForm(request.POST)
        if obj.is_valid():
            print(obj.cleaned_data)
        else:
            print(obj.errors)
        return render(request, 'login.html', {'obj': obj})
</code></pre>

<p><strong><code>login.html:</code></strong></p>
<pre><code class="html">...
&lt;form id=&quot;form&quot; action=&quot;&quot; method=&quot;POST&quot; name=&quot;loginForm&quot; novalidate&gt;
    &lt;!--{{ obj.as_p }}--&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        {{ obj.name.label }}
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;name&quot; placeholder=&quot;请输入用户名&quot; value=&quot;{{ obj.cleaned_data.name }}&quot;&gt;
        &lt;div style=&quot;color: red;font-weight: bold&quot;&gt;{{ obj.errors.name.0 }}&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        {{ obj.pwd.label }}
        &lt;input type=&quot;password&quot; class=&quot;form-control&quot; name=&quot;pwd&quot; placeholder=&quot;请输入密码&quot; value=&quot;{{ obj.cleaned_data.pwd }}&quot;&gt;
        &lt;div style=&quot;color: red;font-weight: bold&quot;&gt;{{ obj.errors.pwd.0 }}&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        {{ obj.email.label }}
        &lt;input type=&quot;email&quot; class=&quot;form-control&quot; name=&quot;email&quot; placeholder=&quot;请输入邮箱&quot; value=&quot;{{ obj.cleaned_data.email }}&quot;&gt;
        &lt;div style=&quot;color: red;font-weight: bold&quot;&gt;{{ obj.errors.email.0 }}&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        {{ obj.phone.label }}
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;phone&quot; placeholder=&quot;请输入手机号&quot; value=&quot;{{ obj.cleaned_data.phone }}&quot;&gt;
        &lt;div style=&quot;color: red;font-weight: bold&quot;&gt;{{ obj.errors.phone.0 }}&lt;/div&gt;
    &lt;/div&gt;
    {% csrf_token %}
    &lt;button id=&quot;loginBtn&quot; type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;登录&lt;/button&gt;
&lt;/form&gt;
...
</code></pre>

<p>上一次验证通过的数据才会被保存：
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200622173852651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" />
<hr></p>
<h4 id="_7">信号</h4>
<hr>

<h5 id="1-django_2">1. Django信号使用场景</h5>
<p>对 Django 数据库中的某张表做增加、删除、修改之前记录一条日志可以使用 Django 中的信号，Django 中的信号是 <font>Django 框架内部帮助开发者预留的可自定义扩展的位置</font>。Flask 和 Scrapy 框架也有信号。
<hr></p>
<h5 id="2-django_3">2. Django内置信号</h5>
<p>Model signals：</p>
<pre><code class="py">pre_init                    # django的modal执行其构造方法前，自动触发
post_init                   # django的modal执行其构造方法后，自动触发
pre_save                    # django的modal对象保存前，自动触发
post_save                   # django的modal对象保存后，自动触发
pre_delete                  # django的modal对象删除前，自动触发
post_delete                 # django的modal对象删除后，自动触发
m2m_changed                 # django的modal中使用m2m字段操作第三张表（add,remove,clear）前后，自动触发
class_prepared              # 程序启动时，检测已注册的app中modal类，对于每一个类，自动触发
</code></pre>

<p>Management signals：</p>
<pre><code class="py">pre_migrate                 # 执行migrate命令前，自动触发
post_migrate                # 执行migrate命令后，自动触发
</code></pre>

<p>Request/response signals：</p>
<pre><code class="py">request_started             # 请求到来前，自动触发
request_finished            # 请求结束后，自动触发
got_request_exception       # 请求异常后，自动触发
</code></pre>

<p>Test signals：</p>
<pre><code class="py">setting_changed             # 使用test测试修改配置文件时，自动触发
    template_rendered           # 使用test测试渲染模板时，自动触发
</code></pre>

<p>Database Wrappers：</p>
<pre><code class="py">connection_created          # 创建数据库连接时，自动触发
</code></pre>

<hr>

<h5 id="3-django_1">3. Django信号简单示例</h5>
<p><strong><code>models.py:</code></strong></p>
<pre><code class="py">from django.db import models

# Create your models here.
class User(models.Model):
    name = models.CharField(max_length=32)
</code></pre>

<p><strong><code>urls.py:</code></strong></p>
<pre><code class="py">from django.urls import path
from app import views

urlpatterns = [
    # path('admin/', admin.site.urls),
    path('func1/', views.func1),
    path('func2/', views.func2),
    path('func3/', views.func3),
    path('func4/', views.func4),
]
</code></pre>

<p><strong><code>views.py:</code></strong></p>
<pre><code class="py">from django.shortcuts import render, HttpResponse
from app.models import User

# Create your views here.
def func1(request):
    &quot;&quot;&quot;
    不会触发保存数据之前的操作（没有保存数据操作）
    :param request:
    :return:
    &quot;&quot;&quot;
    return HttpResponse('创建成功！')

def func2(request):
    &quot;&quot;&quot;
    会触发保存数据之前的操作
    :param request:
    :return:
    &quot;&quot;&quot;
    User.objects.create(name='liki')
    return HttpResponse('创建成功！')

def func3(request):
    User.objects.create(name='thanlon')
    return HttpResponse('创建成功！')

def func4(request):
    User.objects.create(name='kiku')
    return HttpResponse('创建成功！')
</code></pre>

<p><strong><code>__init__.py:</code></strong></p>
<pre><code class="py">from django.db.models import signals


def before_save(*args, **kwargs):
    &quot;&quot;&quot;
    增加之前
    :param args:
    :param kwargs:
    :return:
    &quot;&quot;&quot;
    print(args)  # ()
    print(kwargs)


&quot;&quot;&quot;
{
    'signal': &lt;django.db.models.signals.ModelSignal object at 0x7fb2c41964c0&gt;,
    'sender': &lt;class 'app.models.User'&gt;,
    'instance': &lt;User: User object (None)&gt;,
    'raw': False,
    'using': 'default',
    'update_fields': None
}
&quot;&quot;&quot;


def after_save(*args, **kwargs):
    &quot;&quot;&quot;
    增加之后
    :param args:
    :param kwargs:
    :return:
    &quot;&quot;&quot;
    print(args)  # ()
    print(kwargs)
    &quot;&quot;&quot;
    {
    'signal': &lt;django.db.models.signals.ModelSignal object at 0x7f3196b96400&gt;, 
    'sender': &lt;class 'app.models.User'&gt;, 
    'instance': &lt;User: User object (10)&gt;, 
    'created': True, 
    'update_fields': None, 
    'raw': False, 
    'using': 'default'
    }
    &quot;&quot;&quot;


signals.pre_save.connect(before_save)
signals.post_save.connect(after_save)
&quot;&quot;&quot;
Model signals
    pre_init                    # django的modal执行其构造方法前，自动触发
    post_init                   # django的modal执行其构造方法后，自动触发
    pre_save                    # django的modal对象保存前，自动触发
    post_save                   # django的modal对象保存后，自动触发
    pre_delete                  # django的modal对象删除前，自动触发
    post_delete                 # django的modal对象删除后，自动触发
    m2m_changed                 # django的modal中使用m2m字段操作第三张表（add,remove,clear）前后，自动触发
    class_prepared              # 程序启动时，检测已注册的app中modal类，对于每一个类，自动触发
Management signals
    pre_migrate                 # 执行migrate命令前，自动触发
    post_migrate                # 执行migrate命令后，自动触发
Request/response signals
    request_started             # 请求到来前，自动触发
    request_finished            # 请求结束后，自动触发
    got_request_exception       # 请求异常后，自动触发
Test signals
    setting_changed             # 使用test测试修改配置文件时，自动触发
    template_rendered           # 使用test测试渲染模板时，自动触发
Database Wrappers
    connection_created          # 创建数据库连接时，自动触发
&quot;&quot;&quot;
</code></pre>

<hr>

<h4 id="api">API接口开发</h4>
<hr>

<h5 id="1_7">1. 模型的创建</h5>
<p>创建模型用于测试，设计一张简单的数据表存放在 Pycharm 自带的 sqlite 数据库中：</p>
<p><strong><code>models.py</code></strong></p>
<pre><code class="py">from django.db import models

# Create your models here.
class User(models.Model):
    name = models.CharField(max_length=12)
    register_date = models.DateTimeField(auto_now_add=True, null=True)  # 如果设置为自动设置时间，要添加可以为空，默认是不为空的
</code></pre>

<p>生成数据表：</p>
<pre><code class="py">(DjangoAPI) thanlon@thanlon:~/PycharmProjects/DjangoAPI$ python manage.py makemigrations
(DjangoAPI) thanlon@thanlon:~/PycharmProjects/DjangoAPI$ python manage.py migrate
</code></pre>

<hr>

<h5 id="2_10">2. 路由系统的创建</h5>
<p>添加和查询信息使用的路由是 <strong><code>user/</code></strong>，修改（更新）和删除信息使用路由是 <strong><code>user/&lt;int:pk&gt;/</code></strong>，路由创建如下：</p>
<p><strong><code>urls.py：</code></strong></p>
<pre><code class="py">from django.contrib import admin
from django.urls import path
from app import views

urlpatterns = [
    path('admin/', admin.site.urls),
    path('user/', views.UserView.as_view()),
    path('user/&lt;int:pk&gt;/', views.UserDetail.as_view()),
]
</code></pre>

<hr>

<h5 id="3_8">3. 添加数据的接口</h5>
<p>添加数据的业务逻辑：</p>
<p><strong><code>views.py:</code></strong></p>
<pre><code class="py">class UserView(View):
    def post(self, request):
        &quot;&quot;&quot;
        增加数据
        :param request:
        :return:
        &quot;&quot;&quot;
        # request.POST中是没有数据的，需要在body中获取，但是需要先将bytes-&gt;符串-&gt;反序列化转化成列表对象
        form = UserForm(None, json.loads(request.body.decode()))
        if form.is_valid():
            instance = form.save()
            ret = {
                'status': 0,
                'data': instance.pk
            }
            return JsonResponse(ret)
        else:
            ret = {
                'status': 1,
                'data': form.errors
            }
            return JsonResponse(ret)
</code></pre>

<p>数据验证：</p>
<p><strong><code>user_form.py:</code></strong></p>
<pre><code class="py">from django import forms
from .. import models

class UserForm(forms.Form):
    name = forms.CharField(max_length=10)

    def __init__(self, instence=None, *args, **kwargs):  # 函数传参不要使用可变类型
        self.instence = instence
        super(UserForm, self).__init__(*args, **kwargs)  # 原封不动传过去，这样就可以多传递一个值

    def save(self):
        if self.instence:
            # 通过反射设置新值,不能直接self.instence.name='thanlon'
            # print(self.cleaned_data)
            for k, v in self.cleaned_data.items():
                setattr(self.instence, k, v)
            self.instence.save()
            return self.instence # 更新instence
            # 如果没有数据。校验通过的数据全部放在cleaned_data中，key value组成的字典:{'name': 'thanlon'}
        return models.User.objects.create(**self.cleaned_data)
</code></pre>

<p>添加和修改数据，因为需要有数据传入后台，所以需要对数据进行验证。查询所有数据因为不传入后台任何数据，也无须验证。查询单条数据和删除数据需要进行验证，但不是Form验证，使用路由匹配进行验证！</p>
<p>Postman 向后台发送添加数据的 POST 请求，<font>返回的状态码是0</font>，说明添加成功：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200619220039200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" /></p>
<p>验证数据库，已经添加完成：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200619220354492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" />
<hr></p>
<h5 id="4_5">4. 获取所有数据的接口</h5>
<p>获取所有数据的业务逻辑：</p>
<pre><code class="py">class UserView(View):
    def get(self, request):
        &quot;&quot;&quot;
        查询(所有数据)
        :param request:
        :return:
        &quot;&quot;&quot;
        query_set = models.User.objects.values('name')  # &lt;QuerySet [{'name': 'Erics'}]&gt;
        ret = {
            'status': 0,
            'data': list(query_set)  # 转换成列表,[{'name': 'Erics'}]
        }
        return JsonResponse(ret)
</code></pre>

<p>Postman 向后台发送获取所有数据的 GET 请求，<font>返回的状态码是0</font>，说明查询数据成功：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200619220847519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" />
<hr></p>
<h5 id="5_1">5. 获取单条数据的接口</h5>
<p>获取单条数据的业务逻辑，走的路由是 <strong><code>/user/&lt;int:pk&gt;/</code></strong>：</p>
<p><strong><code>views.py:</code></strong></p>
<pre><code class="py">class UserDetail(View):
    def get(self, request, pk):
        &quot;&quot;&quot;
        查询单条数据
        :param request:
        :param pk:
        :return:
        &quot;&quot;&quot;
        # instence = models.User.objects.filter(pk=pk)
        # print(instence)  # &lt;QuerySet [&lt;User: User object (1)&gt;]&gt;
        instence = models.User.objects.filter(pk=pk).first()
        print(instence)  # User object (1)
        ret = {
            'status': 0,
            'data': {
                'name': instence.name
            }
        }
        return JsonResponse(ret)
</code></pre>

<p>Postman 向后台发送查询单条数据的GET请求，<font>返回的状态码是0</font>，说明添加成功：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200619221220532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" />
<hr></p>
<h5 id="6_1">6. 更新数据的接口</h5>
<p>更新数据的业务逻辑：</p>
<pre><code class="py">class UserDetail(View):
    def put(self, request, pk):
        &quot;&quot;&quot;
        修改数据。restful规定更新数据，用put或者patch，put用得多一些
        :param request:
        :return:
        &quot;&quot;&quot;
        instence = models.User.objects.filter(pk=pk).first()
        if not instence:
            ret = {
                'status': 1,
                'data': {
                    'name': '数据不存在'
                }
            }
            return JsonResponse(ret)
        # 借助form来修改(form中有新数据),降低了耦合度
        form = UserForm(instence, json.loads(request.body.decode()))
        if form.is_valid():
            instence = form.save()  # instence不更新也是可以的，还是查找到的和要修改的id是一样的
            ret = {
                'status': 0,
                'data': instence.pk
            }
            return JsonResponse(ret)
        else:
            ret = {
                'status': 1,
                'data': form.errors
            }
            return JsonResponse(ret)
</code></pre>

<p>数据的验证：</p>
<p><strong><code>user_form.py:</code></strong></p>
<pre><code class="py">from django import forms
from .. import models

class UserForm(forms.Form):
    name = forms.CharField(max_length=10)

    def __init__(self, instence=None, *args, **kwargs):  # 函数传参不要使用可变类型
        self.instence = instence
        super(UserForm, self).__init__(*args, **kwargs)  # 原封不动传过去，这样就可以多传递一个值

    def save(self):
        if self.instence:
            # 通过反射设置新值,不能直接self.instence.name='thanlon'
            # print(self.cleaned_data)
            for k, v in self.cleaned_data.items():
                setattr(self.instence, k, v)
            self.instence.save()
            return self.instence # 更新instence
            # 如果没有数据。校验通过的数据全部放在cleaned_data中，key value组成的字典:{'name': 'thanlon'}
        return models.User.objects.create(**self.cleaned_data)
</code></pre>

<p>Postman 向后台发送更新数据的PUT请求，<font>返回的状态码是0</font>，说明修改成功：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200619223522714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" />
<hr></p>
<h5 id="7_2">7. 删除数据的接口</h5>
<p>删除数据的业务逻辑：</p>
<p><strong><code>views.py:</code></strong></p>
<pre><code class="py">class UserDetail(View):
    def delete(self, request, pk):
        &quot;&quot;&quot;
        删除数据(删除单条数据)
        :param request:
        :param pk:
        :return:
        &quot;&quot;&quot;
        models.User.objects.filter(pk=pk).delete()
        ret = {
            'status': 0,
            'data': []
        }
        return JsonResponse(ret)
</code></pre>

<p><strong><code>user_form.py:</code></strong></p>
<pre><code class="py">class UserForm(forms.Form):
    name = forms.CharField(max_length=10)

    def __init__(self, instence=None, *args, **kwargs):  # 函数传参不要使用可变类型
        self.instence = instence
        super(UserForm, self).__init__(*args, **kwargs)  # 原封不动传过去，这样就可以多传递一个值

    def save(self):
        if self.instence:
            # 通过反射设置新值,不能直接self.instence.name='thanlon'
            # print(self.cleaned_data)
            for k, v in self.cleaned_data.items():
                setattr(self.instence, k, v)
            self.instence.save()
            return self.instence # 更新instence
            # 如果没有数据。校验通过的数据全部放在cleaned_data中，key value组成的字典:{'name': 'thanlon'}
        return models.User.objects.create(**self.cleaned_data)
</code></pre>

<p>Postman 向后台发送添加数据的 <font>DELETE请求</font>，返回的状态码是0，说明删除成功：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2020061922383547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" /></p>
<p><hr>
<div style="width: 60px;height: auto;z-index: 99;bottom: 30%;position: fixed;right: 0px" id="plug-ins">
    <div style="position: relative;float: right">
        <a target="_blank" href="https://blog.csdn.net/thanlon" id="weibo"
           style="display: block;width: 40px;height: 40px;background-color: #c4351b;margin-top: 1px;">
            <img width="22" height="20" src="../img/csdn.jpeg" alt=""
                 style="margin-top: 10px;margin-left: 9px">
        </a>
        <a target="_blank" href="http://wpa.qq.com/msgrd?v=3&uin=3330447288&site=qq&menu=yes" id="qq" style="display: block;width: 40px;height: 40px;background-color:#0e91e8;margin-top: 1px">
            <img width="20" height="20" src="../img/qq.png" 
                 style="margin-top: 10px;margin-left: 10px" alt="点击这里给我发消息" title="点击这里给我发消息">
        </a>
        <a href="javascript:" id="wechat"
           style="display: block;width: 40px;height: 40px;background-color:#01b901;margin-top:1px">
            <img width="22" height="20" src="../img/wechat.png"
                 style="margin-top: 10px;margin-left: 9px">
        </a>
        <a href="javascript:" id="go_top"
           style="display: none;width: 40px;height: 40px;background-color: #b5b5b5;margin-top: 1px">
            <img width="22" height="20" src="../img/top.png" alt=""
                 style="margin-top: 10px;margin-left: 9px">
        </a>
    </div>
</div></p></div>
        </div>

        <footer class="col-md-12">
<!--    <hr>-->
    
    <p>Copyright © 2020-2022 bysj39.com All Rights Reserved.</p>
    <p><a href="https://beian.miit.gov.cn" target="_blank">豫ICP备19037971号-1</a><a target="_blank">
                <img src="http://47.102.145.225:5000/static/home/images/beian.png" style="padding-bottom:6px">
                <span style="color: black">豫公网安备 41152802000091号</span>
            </a></p>
    <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>

        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../js/main.js" defer></script>
        <script src="../js/busuanzi.pure.mini.js" defer></script>
        <script src="../js/gotop.js" defer></script>

        <div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
