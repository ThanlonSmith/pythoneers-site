<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Erics">
        <link rel="canonical" href="https://docs.pythoneers.cn/python-web/flask.html">
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Flask - PYTHONEERS</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <link href="../css/nav.css" rel="stylesheet">
        <link href="../css/public.css" rel="stylesheet">
    

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    <script data-ad-client="ca-pub-6937898095875663" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!--    <script async src="../js/somelib.js"></script>-->
 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="..">PYTHONEERS</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Python <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../python/python3.html">基础到进阶</a>
</li>
                                    
<li >
    <a href="../python/module.html">内置模块与第三方模块</a>
</li>
                                    
<li >
    <a href="../python/algorithm.html">数据结构与算法</a>
</li>
                                    
<li >
    <a href="../python/design-pattern.html">设计模式</a>
</li>
                                    
<li >
    <a href="../python/leetcode.html">Leetcode</a>
</li>
                                    
<li >
    <a href="../python/offer.html">剑指Offer</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Python Web <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="django.html">Django</a>
</li>
                                    
<li >
    <a href="drf.html">Django Rest Framework</a>
</li>
                                    
<li class="active">
    <a href="flask.html">Flask</a>
</li>
                                    
<li >
    <a href="mysql.html">MySQL</a>
</li>
                                    
<li >
    <a href="redis.html">Redis</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Python GUI <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../gui/pyqt5.html">PyQt5</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">网络爬虫 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../web-crawler/scrapy.html">Scrapy</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">数据分析 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../data-analysis/numpy.html">NumPy</a>
</li>
                                    
<li >
    <a href="../data-analysis/pandas.html">Pandas</a>
</li>
                                    
<li >
    <a href="../data-analysis/matplotlib.html">Matplotlib</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">计算机视觉 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../computer-vision/opencv.html">OpenCV</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">机器学习 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../machine-learning/quantitative-trading.html">机器学习与量化交易</a>
</li>
                                </ul>
                            </li>
                            <li >
                                <a href="../deep-learning/deep-learning.html">深度学习</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                            <li >
                                <a rel="next" href="drf.html">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="mysql.html">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#flask">第一个Flask应用</a></li>
            <li><a href="#1-flask">1. Flask概述</a></li>
            <li><a href="#2-wsgi">2. wsgi</a></li>
            <li><a href="#3-flask">3. 安装Flask</a></li>
            <li><a href="#4-werkzurg">4. werkzurg</a></li>
            <li><a href="#5-flask">5. 第一个Flask应用</a></li>
        <li class="main "><a href="#flask_1">Flask配置文件</a></li>
        <li class="main "><a href="#flask_2">Flask路由系统</a></li>
            <li><a href="#1-url">1. 反向生成URL</a></li>
            <li><a href="#2">2. 动态路由的构造</a></li>
        <li class="main "><a href="#flask_3">Flask请求与响应相关数据</a></li>
            <li><a href="#1">1. 请求相关数据</a></li>
            <li><a href="#2_1">2. 响应响应体</a></li>
            <li><a href="#3">3. 响应响应头</a></li>
        <li class="main "><a href="#flask_4">Flask用户认证</a></li>
            <li><a href="#1_1">1. 第一种用户认证</a></li>
            <li><a href="#2_2">2. 装饰器知识点补充</a></li>
            <li><a href="#3-endpoint">3. endpoint参数</a></li>
            <li><a href="#4">4. 装饰器的先后顺序</a></li>
            <li><a href="#5">5. 第二种用户认证方式（装饰器）</a></li>
            <li><a href="#6">6. 第三种用户认证方式（推荐）</a></li>
        <li class="main "><a href="#flaskflash">Flask之flash</a></li>
        <li class="main "><a href="#flask_5">Flask中间件</a></li>
            <li><a href="#1-call">1. call方法的执行</a></li>
            <li><a href="#2_3">2. 自定义中间件</a></li>
        <li class="main "><a href="#flask_6">Flask路由和视图</a></li>
            <li><a href="#1_2">1. 路由和视图函数对应关系</a></li>
            <li><a href="#2_4">2. 路由设置两种方式</a></li>
            <li><a href="#3-approuteappadd_url_url">3. @app.route和app.add_url_url参数</a></li>
            <li><a href="#4-cbv">4. CBV</a></li>
            <li><a href="#5_1">5. 自定义正则</a></li>
        <li class="main "><a href="#flask_7">FLask蓝图</a></li>
            <li><a href="#1_3">1. 蓝图（一）</a></li>
            <li><a href="#2_5">2. 蓝图（二）</a></li>
        <li class="main "><a href="#flasksession">Flask中session的使用</a></li>
            <li><a href="#1-session">1. session的基本使用</a></li>
            <li><a href="#2-session">2. 自定义Session配置</a></li>
        <li class="main "><a href="#flaskwtforms">Flask之wtforms组件</a></li>
            <li><a href="#1_4">1. 用户登录</a></li>
            <li><a href="#2_6">2. 用户注册</a></li>
            <li><a href="#3_1">3. 数据库实时更新</a></li>
            <li><a href="#4-wtformsdjango">4. wtforms的作用与django示例</a></li>
        <li class="main "><a href="#flaskflask-session">FLask之flask-session组件</a></li>
        <li class="main "><a href="#flasksqlalchemy">Flask之SQLAlchemy</a></li>
            <li><a href="#1_5">1. 简介</a></li>
            <li><a href="#2-curd">2. CURD</a></li>
            <li><a href="#3_2">3. 常用操作</a></li>
            <li><a href="#4_1">4. 外键操作</a></li>
            <li><a href="#5_2">5. 多对多操作</a></li>
            <li><a href="#6_1">6. 两种连接数据库的方式</a></li>
            <li><a href="#7-sql">7. 原生SQL</a></li>
        <li class="main "><a href="#pipreqs">pipreqs组件</a></li>
            <li><a href="#1-pipreqs">1. pipreqs的安装</a></li>
            <li><a href="#2-pipreqs">2. pipreqs的应用</a></li>
        <li class="main "><a href="#flask-script">Flask-Script组件</a></li>
            <li><a href="#1-flask-script">1. 安装Flask-Script</a></li>
            <li><a href="#2_7">2. 命令的方式启动项目</a></li>
            <li><a href="#3_3">3. 定制命令</a></li>
            <li><a href="#4-flask-script">4. Flask-Script应用</a></li>
        <li class="main "><a href="#flask-migrate">Flask-Migrate数据库迁移组件</a></li>
        <li class="main "><a href="#flask-sqlalchemy">Flask-SQLALchemy组件</a></li>
            <li><a href="#1-flask-sqlalchemy">1. 安装Flask-SQLALchemy</a></li>
            <li><a href="#2-flask-sqlalchemy">2. 使用Flask-SQLALchemy</a></li>
            <li><a href="#3_4">3. 源码相关图示</a></li>
        <li class="main "><a href="#flask_8">Flask简单登录案例</a></li>
            <li><a href="#1_6">1. 案例目录结构</a></li>
            <li><a href="#2_8">2. 案例主要代码</a></li>
        <li class="main "><a href="#flask_9">Flask模板渲染</a></li>
            <li><a href="#1_7">1. 数据类型的渲染</a></li>
            <li><a href="#2_9">2. 传入函数</a></li>
            <li><a href="#3_5">3. 全局定义函数</a></li>
            <li><a href="#4_2">4. 模板的继承</a></li>
            <li><a href="#5_3">5. 模板的包含</a></li>
            <li><a href="#6_2">6. 宏定义的使用</a></li>
            <li><a href="#7">7. 模板安全</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<p><span id="busuanzi_container_page_pv">阅读量：<span id="busuanzi_value_page_pv"></span>次</span>
<hr></p>
<p><img alt="软件设计模式" src="../img/flask.jpeg" /></p>
<h4 id="flask">第一个Flask应用</h4>
<h6 id="1-flask">1. Flask概述</h6>
<p>Flask框架是一个短小精悍且可扩展强的Web框架，同Django框架一样依赖于第三方实现socket模块。</p>
<blockquote>
<p><strong><code>Flask特有上下文管理机制！</code></strong></p>
</blockquote>
<h6 id="2-wsgi">2. wsgi</h6>
<p>WEB服务网关接口，是一个协议。Flask 中实现该协议的模块有 <strong><code>wsgiref</code></strong> 和 <strong><code>werkzeug</code></strong>，模块本质上就是 <strong><code>socket服务端用于接收客户端的请求并处理</code></strong>。</p>
<blockquote>
<p><strong><code>面试中可能会被用到wsgi是什么？</code></strong></p>
</blockquote>
<h6 id="3-flask">3. 安装Flask</h6>
<p>一般使用 pip 安装 Flask：<strong><code>pip install Flask</code></strong>，如果想加速下载，可以指定国内阿里云 pipy 的源，安装方法是：<strong><code>pip install flask -i https://mirrors.aliyun.com/pypi/simple</code></strong></p>
<h6 id="4-werkzurg">4. werkzurg</h6>
<p>Flask 中实现 wsgi 的模块是 werkzurg，它是Flask第三方模块。</p>
<pre><code class="py">from werkzeug.serving import run_simple

def run(environ, start_response):
    return 'Hello Flask!'

if __name__ == '__main__':
    run_simple('localhost', 5000, run)
</code></pre>

<pre><code class="python">from werkzeug.wrappers import Request, Response
from werkzeug.serving import run_simple

@Request.application
def hello_flask(request):
    return Response('Hello Flask!')

if __name__ == '__main__':
    run_simple('localhost', 5000, hello_flask)
</code></pre>

<blockquote>
<p><strong><code>Django中实现wsgi的模块是wsgiref</code></strong></p>
</blockquote>
<h6 id="5-flask">5. 第一个Flask应用</h6>
<pre><code class="python">from flask import Flask

app = Flask(__name__)  # 实例化Flask类

@app.route('/index')
def index():
    return 'Hello Flask!'

if __name__ == '__main__':
    app.run()  # run方法启动socket
</code></pre>

<h4 id="flask_1">Flask配置文件</h4>
<p>Flask配置文件是一个 <strong><code>flask.config.Config</code></strong> 对象，它继承字典，默认配置文件如下：</p>
<pre><code class="py">print(type(app.config), app.config)
&quot;&quot;&quot;
&lt;class 'flask.config.Config'&gt;
&quot;&quot;&quot;
</code></pre>

<pre><code class="py">{
'ENV': 'production', 
'DEBUG': False, 
'TESTING': False, 
'PROPAGATE_EXCEPTIONS': None,
'PRESERVE_CONTEXT_ON_EXCEPTION': None, 
'SECRET_KEY': None, 
'PERMANENT_SESSION_LIFETIME': datetime.timedelta(days=31),
'USE_X_SENDFILE': False,
'SERVER_NAME': None, 'APPLICATION_ROOT': '/', 
'SESSION_COOKIE_NAME': 'session',
'SESSION_COOKIE_DOMAIN': None, 
'SESSION_COOKIE_PATH': None, 
'SESSION_COOKIE_HTTPONLY': True, 
'SESSION_COOKIE_SECURE': False, 
'SESSION_COOKIE_SAMESITE': None, 
'SESSION_REFRESH_EACH_REQUEST': True, 
'MAX_CONTENT_LENGTH': None, 
'SEND_FILE_MAX_AGE_DEFAULT': datetime.timedelta(seconds=43200), 'TRAP_BAD_REQUEST_ERRORS': None, 
'TRAP_HTTP_EXCEPTIONS': False, 
'EXPLAIN_TEMPLATE_LOADING': False, 
'PREFERRED_URL_SCHEME': 'http', 
'JSON_AS_ASCII': True, 
'JSON_SORT_KEYS': True, 
'JSONIFY_PRETTYPRINT_REGULAR': False, 
'JSONIFY_MIMETYPE': 'application/json', 
'TEMPLATES_AUTO_RELOAD': None, 
'MAX_COOKIE_SIZE': 4093}
</code></pre>

<p>修改默认配置文件，创建配置文件 <strong><code>settings.py</code></strong>，用于存放修改的配置文件：</p>
<p><strong><code>settings.py</code></strong>：</p>
<pre><code class="python"># 存放开发环境、线上环境、测试环境共有的配置文件
class Config(object):
    pass

# 线上环境配置文件
class ProductionConfig(Config):
    DEBUG = False

# 开发环境配置文件
class DevelopmentConfig(Config):
    DEBUG = True

# 测试环境配置文件
class TestingConfig(Config):
    DEBUG = True
</code></pre>

<p><strong><code>app.py：</code></strong></p>
<pre><code class="python">from flask import Flask

app = Flask(__name__)
# print(type(app.config), app.config)
app.config.from_object('settings.DevelopmentConfig')  # 引入配置文件

if __name__ == '__main__':
    app.run()
</code></pre>

<h4 id="flask_2">Flask路由系统</h4>
<blockquote>
<p>@[toc]</p>
</blockquote>
<h6 id="1-url">1. 反向生成URL</h6>
<p>使用 <strong><code>url_for</code></strong> 方法生成 <strong><code>url</code></strong>：</p>
<pre><code class="python">@app.route('/index', methods=['GET', 'POST'], endpoint='name')
def index():
    print(url_for('name'))
    return 'Flask!'
</code></pre>

<p>使用 <strong><code>url_for</code></strong> 方法生成url时设置参数：</p>
<pre><code class="python">@app.route('/index/&lt;int:id&gt;')
def index(id):
    print(url_for('index', id=1))
    return 'Flask!'
&quot;&quot;&quot;
/index/1
&quot;&quot;&quot;
</code></pre>

<p>如果不指定 <strong><code>endpoint</code></strong> 的值，默认为函数名：</p>
<pre><code class="py">def _endpoint_from_view_func(view_func):
    assert view_func is not None, 'expected view func if endpoint ' \
                                  'is not provided.'
    return view_func.__name__ # 返回函数名
def add_url_rule(self,rule,endpoint=None,view_func=None,provide_automatic_options=None, **options):
    if endpoint is None:
        endpoint = _endpoint_from_view_func(view_func)
    options['endpoint'] = endpoint
    methods = options.pop('methods', None)
</code></pre>

<pre><code class="python">@app.route('/index', methods=['GET', 'POST'])
def index():
    print(url_for('index'))
    return 'Flask!'
</code></pre>

<p>如果endpoint非要重名，必须保证函数相同。</p>
<h6 id="2">2. 动态路由的构造</h6>
<pre><code class="python">@app.route('/index/&lt;username&gt;') # 没有指定类型是字符串类型
@app.route('/index/&lt;int:id&gt;')
@app.route('/index/&lt;float:id&gt;') 
@app.route('/index/&lt;path:path&gt;') 
</code></pre>

<p>示例：</p>
<pre><code class="python">@app.route('/index/&lt;float:id&gt;') 
def index(id):
    print(type(id),id)
    return 'Flask!'
</code></pre>

<pre><code class="py">浏览器输入：http://127.0.0.1:5000/index/1.0
控制台输出：&lt;class 'float'&gt; 1.0
</code></pre>

<h4 id="flask_3">Flask请求与响应相关数据</h4>
<blockquote>
<p>@[toc]</p>
</blockquote>
<h6 id="1">1. 请求相关数据</h6>
<p>常用请求的相关信息：</p>
<pre><code class="py">request.method
request.args
request.form
request.cookies
request.headers
</code></pre>

<p>其它请求的相关信息：</p>
<pre><code class="py">request.values
request.path
request.full_path
request.script_root
request.url
request.base_url
request.url_root
request.host_url
request.host
request.files
obj = request.files['the_file_name']
obj.save('/uploads/'+secure_filename(f.filename))
</code></pre>

<h6 id="2_1">2. 响应响应体</h6>
<p>响应字符串：</p>
<pre><code class="python">@app.route('/index')
def index():
    return 'Flask'  # 字符串
</code></pre>

<p>响应模板：</p>
<pre><code class="python">@app.route('/index')
def index():
    return render_template() # 模板
</code></pre>

<p>响应重定向：</p>
<pre><code class="python">@app.route('/index')
def index():
    return redirect('') # 重定向
</code></pre>

<p>响应json格式数据 [<strong><code>from flask import json</code></strong>]：</p>
<pre><code class="python">@app.route('/index')
def index():
    return json.dumps({'name': 'thanlon'})  # {'name': 'thanlon'}
</code></pre>

<p>另一种响应json格式数据的方式 [<strong><code>from flask import jsonify</code></strong>]：</p>
<pre><code class="python">@app.route('/index')
def index():
    return jsonify({'name': 'thanlon'}) # {'name': 'thanlon'}
</code></pre>

<blockquote>
<p><strong><code>不能响应字典，即return dic是错误的!</code></strong></p>
</blockquote>
<h6 id="3">3. 响应响应头</h6>
<p>以上是响应响应体，还可以响应响应头和cookie，只需要从Flask模块中导入make_response进行封装即可。(<strong><code>from flask import make_response</code></strong>）</p>
<p>示例：将字符串类型的响应体与响应头和cookie一同封装响应：</p>
<pre><code class="py">@app.route('/index')
def index():
    obj = make_response('Flask')
    obj.headers['response_flag'] = 'response_info'
    obj.set_cookie('key','value')
    return obj
</code></pre>

<p>响应模板、响应重定向、响应json格式数据和示例就一样的。</p>
<h4 id="flask_4">Flask用户认证</h4>
<blockquote>
<p>@[toc]</p>
</blockquote>
<h6 id="1_1">1. 第一种用户认证</h6>
<p><strong><code>settings.py</code></strong>：</p>
<pre><code class="python"># 存放开发环境、线上环境、测试环境共有的配置文件
class Config(object):
    DEBUG = False
    SECRET_KEY = 'thanlon'
</code></pre>

<p><strong><code>app.py</code></strong>：</p>
<pre><code class="python">from flask import Flask, render_template, redirect, url_for, request, session

app = Flask(__name__)
app.config.from_object('settings.DevelopmentConfig')  # 引入配置文件

USER_DICT = {
    1: {'username': 'thanlon', 'age': '23', 'gender': '男'},
    2: {'username': 'kiku', 'age': '25', 'gender': '女'}
}
@app.route('/login', methods=['GET', 'POST'])  # 默认允许GET请求
def login():
    if request.method == 'GET':
        return render_template('login.html')
    username = request.form.get('username')
    pwd = request.form.get('pwd')
    if username == 'Thanlon' and pwd == '123':
        session['username'] = username  # 默认session保存在签名或加密的cookie中
        return redirect('/index')
    # return render_template('login.html', error='用户名或者密码错误！')
    return render_template('login.html', **{'error': '用户名或者密码错误！'})

@app.route('/index')
def hello_world():
    if not session.get('username'):
        return redirect(url_for('login'))
    return render_template('index.html', user_dict=USER_DICT)

@app.route('/delete/&lt;int:nid&gt;')
def delete(nid):
    if not session.get('username'):
        return redirect(url_for('login'))
    del USER_DICT[nid]
    return redirect(url_for('hello_world'))  # url_for('')写函数名,和路由无关

@app.route('/detail/&lt;int:nid&gt;')
def detail(nid):
    if not session.get('username'):
        return redirect(url_for('login'))
    info = USER_DICT[nid]
    return render_template('detail.html', info=info)

if __name__ == '__main__':
    app.run()
</code></pre>

<p><kbd>index.html</kbd>:</p>
<pre><code class="html">……
&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-md-4&quot;&gt;
            &lt;table class=&quot;table table-hover&quot;&gt;
                &lt;tr&gt;
                    &lt;th style=&quot;text-align: center&quot;&gt;ID&lt;/th&gt;
                    &lt;th style=&quot;text-align: center&quot;&gt;用户名&lt;/th&gt;
                    &lt;th style=&quot;text-align: center&quot;&gt;年龄&lt;/th&gt;
                    &lt;th style=&quot;text-align: center&quot;&gt;性别&lt;/th&gt;
                    &lt;th style=&quot;text-align: center&quot;&gt;操作&lt;/th&gt;
                &lt;/tr&gt;
                {% for k,v in user_dict.items() %}
                    &lt;tr style=&quot;text-align: center&quot;&gt;
                        &lt;td&gt;{{ k }}&lt;/td&gt;
                        &lt;td&gt;{{ v.username }}&lt;/td&gt;
                        &lt;td&gt;{{ v.age }}&lt;/td&gt;
                        &lt;td&gt;{{ v.gender }}&lt;/td&gt;
                        &lt;td&gt;&lt;a href=&quot;/detail/{{ k }}&quot;&gt;详情&lt;/a&gt; | &lt;a href=&quot;/delete/{{ k }}&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;
                    &lt;/tr&gt;
                    {#                    &lt;tr&gt;#}
                    {#                        &lt;td&gt;{{ v['username'] }}&lt;/td&gt;#}
                    {#                        &lt;td&gt;{{ v['age'] }}&lt;/td&gt;#}
                    {#                        &lt;td&gt;{{ v['gender'] }}&lt;/td&gt;#}
                    {#                    &lt;/tr&gt; #}
                    {#                                        &lt;tr&gt;#}
                    {#                                            &lt;td&gt;{{ v.get('usename','默认') }}&lt;/td&gt;#}
                    {#                                            &lt;td&gt;{{ v.get('age') }}&lt;/td&gt;#}
                    {#                                            &lt;td&gt;{{ v.get('gender') }}&lt;/td&gt;#}
                    {#                                        &lt;/tr&gt;#}
                {% endfor %}
            &lt;/table&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
……
</code></pre>

<p><strong><code>detail.html</code></strong>：</p>
<pre><code class="html">……
&lt;body&gt;
{#{'username': 'thanlon', 'age': '23', 'gender': '男'}#}
&lt;br&gt;
{% for item in info.values() %}{#% for item in info.values() %#}
    {{ item }}
{% endfor %}
&lt;/body&gt;
</code></pre>

<h6 id="2_2">2. 装饰器知识点补充</h6>
<p>函数没有加装饰器：</p>
<pre><code class="python"># coding:utf-8
def auth(func):
    def inner(*args, **kwargs):
        ret = func(*args, **kwargs)
        return ret
    return inner
def index():
    print('index')
print(index.__name__)  # 打印函数名
'''index'''
</code></pre>

<p>函数加装饰器，让inner函数伪装成index函数：</p>
<pre><code class="py"># coding:utf-8
def auth(func):
    def inner(*args, **kwargs):
        ret = func(*args, **kwargs)
        return ret
    return inner
@auth
def index():
    print('index')
@auth
def login():
    print('login')
print(index.__name__)  # 打印函数名
print(login.__name__)  # 打印函数名
'''inner'''
'''inner'''
</code></pre>

<p>上面的例子中加装饰器虽然把名字伪装成功，但是内部没有伪装成功，可以使用functools.wraps(func)：把原来函数执行的信息放到inner函数中（把原来的函数名放进闭包）：</p>
<pre><code class="python"># coding:utf-8
import functools
def auth(func):
    @functools.wraps(func)
    def inner(*args, **kwargs):
        ret = func(*args, **kwargs)
        return ret
    return inner
@auth
def index():
    print('index')
@auth
def login():
    print('login')
print(index.__name__)  # 打印index函数名
print(login.__name__)  # 打印login函数名
'''
index
login
'''
</code></pre>

<h6 id="3-endpoint">3. endpoint参数</h6>
<p>可以指定，默认是函数名。作用是：反向生成url，如果同名会出错。查看route函数源码：</p>
<pre><code class="py">def add_url_rule(self, rule, endpoint=None, view_func=None,
provide_automatic_options=None, **options):
    if view_func is not None:
    old_func = self.view_functions.get(endpoint)
    if old_func is not None and old_func != view_func:
        raise AssertionError('View function mapping is overwriting an ''existing endpoint function: %s' % endpoint)
            self.view_functions[endpoint] = view_func
……

def route(self, rule, **options):
    def decorator(f):
        endpoint = options.pop('endpoint', None)
        self.add_url_rule(rule, endpoint, f, **options)
        return f
    return decorator
</code></pre>

<h6 id="4">4. 装饰器的先后顺序</h6>
<p>装饰器和路由配合，把url和函数加入到路由关系中：</p>
<pre><code class="python">@app.route('/login', methods=['GET', 'POST'])  # 默认允许GET请求
def hello_world():
    if not session.get('username'):
        return redirect(url_for('login'))
    return render_template('index.html', user_dict=USER_DICT)
</code></pre>

<p>如果想要再加入一个登录验证的装饰器，如果把 <strong><code>@auth&lt;/kbd&gt;加入到&lt;kbd&gt;@app.route('/login', methods=['GET', 'POST'])</code></strong> 上面，那就是url和函数是一个大整体，再用 <strong><code>@auth</code></strong> 装饰，这显然不是我们的目标。函数应该优先和 <strong><code>@auth</code></strong> 结合，再去做路由和函数的路由对应关系。装饰完成之后，多个路由都对应 inner，endpoint 默认是函数名，这样所有的函数都是 inner，这也是有问题。有两种解决方式。</p>
<p>方式一：自己定义endpoint，</p>
<pre><code class="py">@app.route('/index',endpoint='1')
……
@app.route('/delete/&lt;int:nid&gt;',endpoint='2')
……
</code></pre>

<p>方式二：使用 <strong><code>@functools.wraps(func)</code></strong></p>
<pre><code class="python">import functools
def auth(func):
    @functools.wraps(func)
    def inner(*args, **kwargs):
        result = func(*args, **kwargs)
        return result
    return inner

@app.route('/index', endpoint='1')
@auth
def hello_world():
    if not session.get('username'):
        return redirect(url_for('login'))
    return render_template('index.html', user_dict=USER_DICT)
</code></pre>

<h6 id="5">5. 第二种用户认证方式（装饰器）</h6>
<p><strong><code>app.py</code></strong>：</p>
<pre><code class="python">def auth(func):
    @functools.wraps(func)
    def inner(*args, **kwargs):
        result = func(*args, **kwargs)
        return result
    return inner

@app.route('/index', endpoint='1')
@auth
def hello_world():
    if not session.get('username'):
        return redirect(url_for('login'))
    return render_template('index.html', user_dict=USER_DICT)
</code></pre>

<p>这有个不好的地方，就是每一个需要做认证的都需要一个一个加入装饰器<kbd>@auth</kbd>。</p>
<blockquote>
<p><strong><code>应用场景：比较少的函数中需要额外加入功能。</code></strong></p>
</blockquote>
<h6 id="6">6. 第三种用户认证方式（推荐）</h6>
<p>可以使用 <strong><code>before_request</code></strong>，返回None表示可以通过执行，如果返回其它，不能通过执行：</p>
<pre><code class="py">@app.before_request
def auth():
    if request.path == '/login':
        return None
    if session.get('username'):
        return None
    # return redirect('/login')
    return redirect(url_for('login'))
</code></pre>

<blockquote>
<p><strong><code>应用场景：批量给函数加额外的功能!</code></strong></p>
</blockquote>
<h4 id="flaskflash">Flask之flash</h4>
<pre><code class="py">@app.route('/page1')
def page1():
    session['xxx'] = 123456
    return 'session'

@app.route('/page2')
def page2():
    print(session.get('xxx'))  # print(session['xxx'])
    del session['xxx']
    session.pop('xxx')
    return 'session'
</code></pre>

<pre><code class="py">@app.route('/page1')
def page1():
    flash('临时数据存储') # 临时存在内存中一个数据
    return 'session'

@app.route('/page2')
def page2():
    print(get_flashed_messages()) # 取一次就没有了,实际上用的时pop
    return 'session'
'''
''' 
['临时数据存储', '临时数据存储']
[]
'''
'''
</code></pre>

<p>对临时数据也可以做分类：</p>
<pre><code class="py">@app.route('/page1')
def page1():
    flash('临时数据存储','info')
    flash('error','error')
    return 'session'

@app.route('/page2')
def page2():
    print(get_flashed_messages(category_filter=['error']))
    return 'session'

''' 
['error', 'error']
[]
'''
</code></pre>

<h4 id="flask_5">Flask中间件</h4>
<blockquote>
<p>@[toc]</p>
</blockquote>
<h6 id="1-call">1. call方法的执行</h6>
<p>call方法在用户发起请求时才执行。flask 依赖 wsgi ，程序启动时执行的是 <strong><code>run_simple(host, port, self, **options)</code></strong>。在 <strong><code>app.py</code></strong> 文件中，会把 app 对象传入 run_simple 方法中。请求进来，第三个参数加括号，<strong><code>对象加括号执行__call__方法</code></strong>。</p>
<pre><code class="py">def wsgi_app(self, environ, start_response):
        ctx = self.request_context(environ)
        error = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
                response = self.handle_exception(e)
            except:
                error = sys.exc_info()[1]
                raise
            return response(environ, start_response)
        finally:
            if self.should_ignore_error(error):
                error = None
            ctx.auto_pop(error)
    def __call__(self, environ, start_response):
        return self.wsgi_app(environ, start_response)
</code></pre>

<p>所有的请求入口就在 call 方法。</p>
<pre><code class="py">if __name__ == '__main__':
    app.run()
</code></pre>

<p><strong><code>app.run()</code></strong> 方法执行后，运行 <strong><code>run_simple(host, port, self, **options)</code></strong>，在内部就是死循环，等待客户端发送请求（socket在监听连接）。此时 <strong><code>__call__</code></strong> 方法不会执行，有请求就会执行该方法。</p>
<p>修改源码：</p>
<pre><code class="py">def __call__(self, environ, start_response):
        &quot;&quot;&quot;The WSGI server calls the Flask application object as the
        WSGI application. This calls :meth:`wsgi_app` which can be
        wrapped to applying middleware.&quot;&quot;&quot;
        print('请求之前做的操作')
        data = self.wsgi_app(environ, start_response)
        print('请求之后做的操作')
        return data
</code></pre>

<pre><code class="py">if __name__ == '__main__':
    app.run()
</code></pre>

<pre><code class="py">'''
请求之前做的操作
请求之后做的操作
'''
</code></pre>

<p>这样做是不合适的，修改源代码是不可选的。</p>
<h6 id="2_3">2. 自定义中间件</h6>
<pre><code class="py">class Middleware(object):
    def __init__(self, old):
        self.old = old

    def __call__(self, *args, **kwargs):
        print('请求之前做的操作')
        ret = self.old(*args, **kwargs)
        print('请求之后做的操作')
        return ret

if __name__ == '__main__':
    app.wsgi_app = Middleware(app.wsgi_app)
    app.run()
</code></pre>

<p>通过 Middleware 中间件，在请求之前和请求之后做一些操作。  </p>
<h4 id="flask_6">Flask路由和视图</h4>
<blockquote>
<p>@[toc]</p>
</blockquote>
<h6 id="1_2">1. 路由和视图函数对应关系</h6>
<pre><code class="py"># /index和/login是路由;index和login是视图函数
[
    ('/index', 'index'),
    ('/login', 'login')
]
</code></pre>

<p>请求来了，一个个筛选，并且前面的匹配成功，后面的都不再进行匹配了。</p>
<h6 id="2_4">2. 路由设置两种方式</h6>
<p>① @app.route('/xxx')</p>
<pre><code class="py">@app.route('/')
def index():
    return 'index'
</code></pre>

<p>② app.add_url_rule('/index',None,index)</p>
<pre><code class="py">def index():
    return 'index'
app.add_url_rule('/index', None, index)
</code></pre>

<p>注意：不要让endpoint重名，如果重名函数一定要相同。</p>
<pre><code class="py">@app.route('/index', endpoint=1)
def index():
    return 'index'
@app.route('/index', endpoint=1)
def index():
    return 'index'
</code></pre>

<p>上面两个index函数是不同的。</p>
<h6 id="3-approuteappadd_url_url">3. @app.route和app.add_url_url参数</h6>
<ul>
<li>rule：url规则</li>
<li>view_func：视图函数名称</li>
<li>defaults = None：默认值，当url中无参数数时，使用defaults = {'k':'v'}为函数提供参数</li>
</ul>
<pre><code class="py">@app.route('/index', defaults={'k': 'v'})
def index(k):
    return 'index'
</code></pre>

<ul>
<li>endpoint = None：名称，用于反向生成 url，即 url_for('名称')</li>
<li>methods = None：允许请求的方式，如：['get','post']</li>
<li>strict_slashes  = None：对url最后/符号是严格要求的。对于@app.route('/login',strict_slashes = False)，访问<a href="https://www.blueflags.cn/login">https://www.blueflags.cn/login</a>或<a href="https://www.blueflags.cn/login/">https://www.blueflags.cn/login/</a>都可以。但对于@app.route('/login',strict_slashes = True)，仅能访问<a href="https://www.blueflags.cn/login">https://www.blueflags.cn/login</a>。建议使strict_slashes = True，只有写了什么，才能访问什么，默认也是True。</li>
<li>redirect_to = None：重定向到指定的地址</li>
</ul>
<p>① 一般的重定向：</p>
<pre><code class="py">@app.route('/index', redirect_to='/login')
def index():
    return 'index'

@app.route('/login')
def login():
    return 'login'
</code></pre>

<p>② 重定向的时候传参数：</p>
<pre><code class="py">@app.route('/index/&lt;int:nid&gt;', redirect_to='/home/&lt;nid&gt;')
def index():
    return 'index'

@app.route('/home/&lt;int:nid&gt;')
def home(nid):
    return str(nid)
</code></pre>

<pre><code class="py">def func(adapter, nid):
    return '/home/' + str(nid)

@app.route('/index/&lt;int:nid&gt;', redirect_to=func)
def index():
    return 'index'
</code></pre>

<ul>
<li>subdomain = None：子域名访问
绑定域名：</li>
</ul>
<p><kbd>hosts</kbd></p>
<pre><code class="py"># localhost name resolution is handled within DNS itself.
#   127.0.0.1       localhost
#   ::1             localhost
    127.0.0.1       thanlon.com
    127.0.0.1       home.thanlon.com
    127.0.0.1       admin.thanlon.com
</code></pre>

<p><kbd>app.py</kbd>：</p>
<pre><code class="py">from flask import Flask
app = Flask(__name__)
app.config['SERVER_NAME'] = 'thanlon.com:5000'

# http://admin.thanlon.com:5000
@app.route('/index', subdomain='admin')
def admin():
    return 'admin.thanlon.com'

# http://home.thanlon.com:5000
@app.route('/index', subdomain='home')
def home():
    return 'home.thanlon.com'

if __name__ == '__main__':
    app.run()
</code></pre>

<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190814154557908.png" /><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190814154545228.png" /></p>
<pre><code class="py">from flask import Flask
app = Flask(__name__)
app.config['SERVER_NAME'] = 'thanlon.com:5000'

# http://xxxxx.thanlon.com:5000
@app.route('/', subdomain='&lt;username&gt;')
def index(username):
    return username + '.thanlon.com'

if __name__ == '__main__':
    app.run()
</code></pre>

<h6 id="4-cbv">4. CBV</h6>
<pre><code class="py">from flask import Flask, views
import functools
app = Flask(__name__)

def wrapper(func):
    @functools.wraps(func)
    def inner(*args, **kwargs):
        return func(*args, **kwargs)
    return inner

class UserView(views.MethodView):
    methods = ['GET']  # 表示只支持get请求
    decorators = [wrapper]  # 在执行get和post时，先执行这个装饰器

    def get(self, *args, **kwargs):
        return 'GET'

    def post(self, *args, **kwargs):
        return 'POST'

app.add_url_rule('/index', None, UserView.as_view('uuu'))
</code></pre>

<h6 id="5_1">5. 自定义正则</h6>
<ul>
<li>python默认支持的转换器</li>
</ul>
<pre><code class="py">#: the default converter mapping for the map.
DEFAULT_CONVERTERS = {
    &quot;default&quot;: UnicodeConverter,
    &quot;string&quot;: UnicodeConverter,
    &quot;any&quot;: AnyConverter,
    &quot;path&quot;: PathConverter,
    &quot;int&quot;: IntegerConverter,
    &quot;float&quot;: FloatConverter,
    &quot;uuid&quot;: UUIDConverter,
}
</code></pre>

<ul>
<li>自定义正则的三个步骤</li>
</ul>
<p>① 定制类</p>
<pre><code class="py">class RegexConverter(BaseConveter):
    def __init__(self,map,regex):
        super(RegexConverter,self).__ini__(map)
        self.regex = regex

    def to_python(self,value):
        # 路由匹配时，匹配成功后传递给视图函数中参数的值
        return int(value) # 可以做一些自定义操作

    def to_url(self,value):
        # 反向生成url
        var = super(RegexConverter, self).to_url(value)
        return var
</code></pre>

<p>② 添加转换器</p>
<pre><code class="py">app.url_map.converters['reg'] = RegexConverter  # reg是自己定义
</code></pre>

<p>③ 使用自定义正则（to_python方法是匹配的时候使用，to_url方法是反向生成url的时候使用）</p>
<pre><code class="py">from flask import Flask, url_for

app = Flask(__name__)
from werkzeug.routing import BaseConverter

# 第一步：定制类
class RegexConverter(BaseConverter):
    def __init__(self, map, regex):
        super(RegexConverter, self).__init__(map)
        self.regex = regex

    def to_python(self, value):
        return str(value)

    def to_url(self, value):
        var = super(RegexConverter, self).to_url(value)
        return var

# 第二步：添加转换器
app.url_map.converters['reg'] = RegexConverter  # reg是自己定义

# 第三步：使用自定义正则（to_python方法是匹配的时候使用，to_url方法是反向生成url的时候使用）
# 如果匹配成功，执行to_python方法，该方法返回什么，nid就是什么
@app.route(&quot;/index/&lt;reg('\d+'):nid&gt;&quot;, methods=['GET'])
def index(nid):
    '''
    1. 用户发送请求
    2. flask内部进行正则匹配
    3. 调用to_python(正则匹配的结果)方法
    4. to_python方法的返回值会交给视图函数的参数
    :param nid: 
    :return: 
    '''
    # print(nid, type(nid))  # 查看nid的类型
    print(url_for('index', nid=123))  # 如果反向生成url，执行流程，先将参数nid=123传入to_url方法，让to_url方法帮助我们去反向生成。
    '''
    控制台：/index/123
    '''
    return 'index'

if __name__ == '__main__':
    app.run()
</code></pre>

<h4 id="flask_7">FLask蓝图</h4>
<blockquote>
<p>@[toc]</p>
</blockquote>
<h6 id="1_3">1. 蓝图（一）</h6>
<p>实际项目中，需要进行项目目录结构的划分，蓝图就是用来帮助开发者进行目录结构的划分，下面是目录结构划分的几个步骤。
① 新建项目，在项目下新建一个和项目名同名的目录
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190815094530310.png" />
②  在与项目名同名的目录中新建<kbd><strong> init </strong>.py</kbd>，用来实例化Flask对象
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190815095502946.png" /></p>
<pre><code class="py">from flask import Flask

def create_app():
    app = Flask(__name__)
    return app
</code></pre>

<p>③ 在项目目录下新建<kbd>manage.py</kbd>(也可以是其它的名字)，
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190815095847799.png" />
将create_app函数导入manage.py，在manage.py中：</p>
<pre><code class="py">from test_blueprint import create_app

app = create_app()
if __name__ == '__main__':
    app.run()
</code></pre>

<p>④ 在test_blueprint(非项目目录)下新建views目录，用来放视图函数，在视图函数中可以根据视图的不同进行分类。
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190815101405871.png" />
⑤  创建视图函数与app对象的关系，首先在视图函数中，创建Blueprint对象。</p>
<p><kbd>admin.py</kbd></p>
<pre><code class="py">from flask import Blueprint
admin_bp = Blueprint('admin_bp', __name__)  # 创建Blueprint(蓝图)对象，第一个参数name不能同名

@admin_bp.route('/login')
def login():
    return 'admin.login'

@admin_bp.route('/logout')
def logout():
    return 'logout'
</code></pre>

<p><kbd>home.py</kbd></p>
<pre><code class="py">from flask import Blueprint
home_bp = Blueprint('home_bp', __name__)  # 第一个参数是name，第一个参数name不能同名

@home_bp.route('/login')
def login():
    return 'home.login'

@home_bp.route('/list')
def list():
    return 'list'
</code></pre>

<p>需要修改<kbd><strong> init </strong>.py</kbd>，注册蓝图，</p>
<pre><code class="python">from flask import Flask
from .views.admin import admin_bp
from .views.home import home_bp

def create_app():
    app = Flask(__name__)
    # 注册蓝图
    app.register_blueprint(home_bp)
    app.register_blueprint(admin_bp)
    return app
</code></pre>

<p>注意：如果两个或多个视图函数中有同名的路由，如home.py和admin.py都有<kbd>/login</kbd>路由，谁先注册先执行谁的视图函数。</p>
<p>⑥ 创建模板。在__ init __.py所在的目录中新建<kbd>templates</kbd>目录(Flask实例化的文件所在的目录中)，如果有静态文件，放静态文件的目录<kbd>static</kbd>与templates目录处于同一级。
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190815105313126.png" />
在templates目录中建模板文件<kbd>login.html</kbd>，可以修改<kbd>admin.py</kbd>，</p>
<pre><code class="py">@admin_bp.route('/login')
def login():
    return render_template('login.html')
</code></pre>

<p>这时候就可以访问模板了。</p>
<h6 id="2_5">2. 蓝图（二）</h6>
<p>① 自定义静态文件和模板的路径</p>
<pre><code class="py">admin_bp = Blueprint('admin_bp', __name__,template_folder='xxx')
@admin_bp.route('/login')
def login():
    return render_template('login.html')
</code></pre>

<p>注意：蓝图<strong>优先</strong>去templates去找loging.html，找不到去xxx中找。当然静态文件也是可以指定的：</p>
<pre><code class="py">admin_bp = Blueprint('admin_bp', __name__,template_folder='xxx',static_folder='xxxx')

@admin_bp.route('/login')
def login():
    return render_template('login.html')
</code></pre>

<p>②  为某一个蓝图地址加上前缀</p>
<pre><code class="py">def create_app():
    app = Flask(__name__)
    # 注册蓝图
    app.register_blueprint(home_bp, url_prefix='/home')
    app.register_blueprint(admin_bp)
    return app
</code></pre>

<p>按照原先访问方式：<kbd>http://127.0.0.1:5000/login</kbd> ,访问失败。</p>
<p>现在需要：<kbd>http://127.0.0.1:5000/home/login</kbd></p>
<p>③ 为所有蓝图加上<kbd>@before_request</kbd></p>
<p><kbd><strong> init </strong>.py</kbd>：</p>
<pre><code class="py">from flask import Flask
from .views.admin import admin_bp
from .views.home import home_bp

def create_app():
    app = Flask(__name__)

    @app.before_request
    def xxx():
        return '123'

    # 注册蓝图
    app.register_blueprint(home_bp)
    app.register_blueprint(admin_bp)
    return app
</code></pre>

<p>④ 为指定的蓝图加上<kbd>@before_request</kbd></p>
<p><kbd>admin.py</kbd>：</p>
<pre><code class="py">from flask import Blueprint, render_template
admin_bp = Blueprint('admin_bp', __name__, template_folder='xxx', static_folder='xxxx')

@admin_bp.before_request
def xxx():
    return '123'

@admin_bp.route('/login')
def login():
    return render_template('login.html')

@admin_bp.route('/logout')
def logout():
    return 'logout'
</code></pre>

<blockquote>
<p><strong><code>应用场景：可以在指定蓝图中加入登录验证。</code></strong></p>
</blockquote>
<h4 id="flasksession">Flask中session的使用</h4>
<blockquote>
<p>@[toc]</p>
</blockquote>
<h6 id="1-session">1. session的基本使用</h6>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190811121342441.png" />
当请求刚进来时，flask 读取 cookie 中 session 对应的值，将该值解密并反序列化为字典，放入内存以便视图函数使用。 </p>
<p><kbd>视图函数</kbd>： </p>
<pre><code class="py">@app.route('/session')
def sess():
    # from flask.sessions import SecureCookieSession
    print(type(session))  # session继承了字典，字典有什么方法，它就有什么方法
    session['k1'] = 'v1'
    return 'session'
    '''
    &lt;class 'werkzeug.local.LocalProxy'&gt;
    '''
</code></pre>

<p>当请求结束时，flask会读取内存中字典的值，进行序列化加密，写入到用户的cookie中。</p>
<h6 id="2-session">2. 自定义Session配置</h6>
<p><kbd>settings.py</kbd>：</p>
<pre><code class="py">class Config(object):
    # PERMANENT_SESSION_LIFETIME = datetime.timedelta(days=31)  # 生命周期，最多的保存时间
    # PERMANENT_SESSION_LIFETIME = datetime.timedelta(hours=1)
    PERMANENT_SESSION_LIFETIME = datetime.timedelta(minutes=30)  # 30min后过期
    SESSION_COOKIE_NAME = 'session',  # cookie的名称
    SESSION_COOKIE_DOMAIN = None,  # 域名
    SESSION_COOKIE_PATH = None  # 路径
    SESSION_COOKIE_HTTPONLY = True  # http读取
    SESSION_COOKIE_SECURE = False  # 安全设置
    SESSION_REFRESH_EACH_REQUEST = True  # 在最后访问的基础上加上生命周期
</code></pre>

<h4 id="flaskwtforms">Flask之wtforms组件</h4>
<blockquote>
<p>@[toc]</p>
</blockquote>
<h6 id="1_4">1. 用户登录</h6>
<p><strong><code>form.py</code></strong>：</p>
<pre><code class="py"># coding:utf-8
from wtforms import Form
from wtforms.fields import simple
from wtforms import widgets, validators

class LoginForm(Form):
    # name = simple.StringField()
    name = simple.StringField(
        validators=[
            validators.DataRequired(message='用户名不能为空'),
            validators.Length(min=6,max=20,message='用户名长度必须大于%(min)d且小于%(max)d')
        ],
        widget=widgets.TextInput(),
        render_kw={'placeholder': '请输入用户名', 'class': 'form-control'}
    )
    # pwd = simple.PasswordField()
    pwd = simple.PasswordField(
        validators=[
            validators.DataRequired(message='密码不能为空')
        ],
        render_kw={'placeholder': '请输入密码','class': 'form-control'}
    )
</code></pre>

<p><kbd>app.py</kbd>：</p>
<pre><code class="py">from flask import Flask, render_template, request
from forms import LoginForm

app = Flask(__name__)
app.debug = True

@app.route('/')
def index():
    return 'index'

@app.route('/login', methods=['get', 'post'])
def login():
    if request.method == 'GET':
        form = LoginForm()
        # print(form.name, type(form.name))  # name是一个对象,print的时候执行这个对象的__str__方法,
        # print(form.pwd, type(form.pwd))  # name是一个对象,print的时候执行这个对象的__str__方法
        '''
       &lt;input id=&quot;name&quot; name=&quot;name&quot; type=&quot;text&quot; value=&quot;&quot;&gt; &lt;class 'wtforms.fields.core.StringField'&gt;
        &lt;input id=&quot;pwd&quot; name=&quot;pwd&quot; type=&quot;password&quot; value=&quot;&quot;&gt; &lt;class 'wtforms.fields.simple.PasswordField'&gt;
        '''
        return render_template('login.html', form=form)
    form = LoginForm(formdata=request.form)
    if form.validate():
        print(form.data)  # {'name': '123456', 'pwd': '123456'}
        return '验证成功!'
    else:
        # print(form.errors)  # {'name': ['用户名不能为空'], 'pwd': ['密码不能为空']}
        return render_template('login.html', form=form)

if __name__ == '__main__':
    app.run()
</code></pre>

<p><kbd>login.html</kbd>：</p>
<pre><code class="html">  &lt;form method=&quot;POST&quot; novalidate&gt;
                        &lt;div class=&quot;form-group&quot;&gt;
                            &lt;label&gt;用户名&lt;/label&gt;
                            {{form.name}}
                            &lt;div style=&quot;color:red&quot;&gt;{{form.name.errors[0]}}&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class=&quot;form-group&quot;&gt;
                            &lt;label&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码&lt;/label&gt;
                             {{form.pwd}}
                            &lt;div style=&quot;color:red&quot;&gt;{{form.pwd.errors[0]}}&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;登录&lt;/button&gt;
                    &lt;/form&gt;
</code></pre>

<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190905181115785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" /></p>
<h6 id="2_6">2. 用户注册</h6>
<p><kbd>form.py</kbd>：</p>
<pre><code class="py">class RegisterForm(Form):
    name = simple.StringField(
        label='用户名',
        validators=[
            validators.DataRequired(message='密码不能为空!')
        ],
        widget=widgets.TextInput(),
        render_kw={'class': 'form-control'},
        default='thanlon'
    )
    pwd = simple.PasswordField(
        label='密码',
        validators=[
            validators.DataRequired(message='密码不能为空!')
        ],
        widget=widgets.PasswordInput(),
        render_kw={
            'class': 'form-control'
        }
    )
    pwd_confirm = simple.PasswordField(
        label='重复密码',
        validators=[
            validators.DataRequired(message='重复密码不能为空!'),
            validators.EqualTo('pwd', message='两次密码输入不一致!')
        ],
        widget=widgets.PasswordInput(),
        render_kw={
            'class': 'form-control'
        }
    )
    email = html5.EmailField(
        label='邮箱',
        validators=[
            validators.DataRequired(message='邮箱不能为空!'),
            validators.Email(message='邮箱格式错误!')
        ],
        widget=widgets.TextInput(input_type='email'),
        render_kw={
            'class': 'form-control'
        }
    )
    gender = core.RadioField(
        label='性别',
        choices=(
            (1, '男'), (2, '女')
        ),
        coerce=int,  # int('1')

    )
    city = core.SelectField(
        label='城市',
        choices=(
            ('bj', '北京'),
            ('sh', '上海')
        )
    )
    hobby = core.SelectMultipleField(
        label='爱好',
        choices=(
            (1, '羽毛球'),
            (2, '篮球')
        ),
        coerce=int
    )
    favor = core.SelectMultipleField(
        label='喜好',
        choices=(
            (1, '羽毛球'),
            (2, '篮球')
        ),
        widget=widgets.ListWidget(prefix_label=False),
        option_widget=widgets.CheckboxInput(),
        coerce=int,
        default=[2]
    )
</code></pre>

<p><kbd>register.html</kbd>：</p>
<pre><code class="py">&lt;form method=&quot;post&quot; novalidate&gt;
    {% for field in form %}
    {{field.label}} {{field}}{{field.errors[0]}}
    {% endfor %}
    &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;登录&lt;/button&gt;
 &lt;/form&gt;
</code></pre>

<p><kbd>app.py</kbd>：</p>
<pre><code class="py">@app.route('/register',methods=['get','post'])
def register():
    if request.method == 'GET':
        form = RegisterForm()
        return render_template('register.html', form=form)
    form = RegisterForm(formdata=request.form)
    if form.validate():
        print(form.data)
        return redirect('https://www.blueflags.cn')
    return render_template('register.html', form=form)
</code></pre>

<h6 id="3_1">3. 数据库实时更新</h6>
<p>① 数据相关</p>
<pre><code class="sql">mysql&gt; create table city(id int primary key auto_increment,city_name varchar(20) not null );
mysql&gt; insert city values(null,'beijin');
mysql&gt; insert city values(null,'shanghai');
mysql&gt; insert city values(null,'shenzhen'); 
</code></pre>

<p>② 效果图
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190906143006821.png" />
③ 主要代码</p>
<pre><code class="py">class UserForm(Form):
    city = core.SelectField(
        label='城市',
        choices=helper.fetch_all('select *from city', [], type=None),  # 只是在第一次从数据库获取一次
        coerce=int,  # 自动把用户提交的字符串转换为数字
    )
</code></pre>

<p>选项中的数据只是在第一次请求的时候从数据库获取一次，当数据更新时，用户页面中的数据并没有实时更新。所以，代码是存在问题的。</p>
<p>解决方案：对于UserForm类，每次实例化的时候都去从数据库中获取一次数据，可以这样写：</p>
<pre><code class="py">class UserForm(Form):
    city = core.SelectField(
        label='城市',
        choices=(),  # 只是在第一次从数据库获取一次
        coerce=int,  # 自动把用户提交的字符串转换为数字
    )

    # 如果没有写执行Form的构造方法
    def __init__(self, *args, **kwargs):
        super(UserForm, self).__init__(*args, **kwargs)  # 在UserForm中执行什么在父类中还要执行什么
        self.city.choices = helper.fetch_all('select *from city', [], type=None)
</code></pre>

<p>实例化UserForm的时候传值：</p>
<pre><code class="py">@app.route('/user', methods=['get', 'post'])
def user():
    if request.method == 'GET':
        form = UserForm(data = {'name':'thanlon','city':3})
        return render_template('user.html',form=form)
</code></pre>

<h6 id="4-wtformsdjango">4. wtforms的作用与django示例</h6>
<p>wtforms有两个作用：1. 自动生成html标签；2.对用户请求数据进行校验
在django中想实现实时更新，也需要重写构造方法。</p>
<p><kbd>views.py</kbd>：</p>
<pre><code class="py">from django.shortcuts import render
from django.forms import Form
from django.forms import fields
from app01 import models

class IndexForm(Form):
    title = fields.CharField()
    # group = fields.ChoiceField(
    #     choices=(
    #         (1, 'A'),
    #         (2, 'B')
    #     )
    # )
    group = fields.ChoiceField(
        choices=()
    )
    def __init__(self, *args, **kwargs):
        super(IndexForm, self).__init__(*args, **kwargs)
        self.fields['group'].choices = models.UserGroup.objects.all().values_list('id', 'title')

# Create your views here.
def index(request):
    if request.method == 'GET':
        form = IndexForm()
        return render(request, 'index.html', {'form': form})
</code></pre>

<h4 id="flaskflask-session">FLask之flask-session组件</h4>
<p>flask-sesion组件可以帮助我们把默认的 session 放入到加密的 cookie 中。</p>
<p>（1）安装 flask-session：<strong><code>pip install flask-session</code></strong></p>
<p>（2）session 保存在 Redis 中</p>
<pre><code class="py"># coding:utf-8
from flask import Flask, request, session
from flask.sessions import SecureCookieSessionInterface
# from flask.ext.session import Session#以前导入session的方式，与下面是一样的
from flask_session import Session
import redis

app = Flask(__name__)
'''
session保存在redis中
'''
# app.session_interface = SecureCookieSessionInterface()  # 默认
# app.session_interface 换成flaks-session中的内容
# app.session_interface =RedisSessionInterface()
app.config['SESSION_TYPE'] = 'redis'
app.config['SESSION_REDIS'] = redis.Redis(host='主机IP', port=6739, password='密码!')
Session(app)

@app.route('/login')
def login():
    session['user'] = 'thanlon'
    return '……'

@app.route('/')
def index():
    print(session.get('user'))  # 没有不报错，session['user']没有会报错
    return 'index'

if __name__ == '__main__':
    app.run()
    # app.__call__  # 请求进来执行__call__，把数据交给__call__方法
    # app.wsgi_app  # __call__方法会调用wsgi_app
</code></pre>

<p>（3）查看Redis中存入的session</p>
<p><kbd>look_cookie.py</kbd>:</p>
<pre><code class="py"># coding:utf-8
import redis
conn = redis.Redis(host='106.12.115.136',port=6379)
print(conn.keys())
'''
[b'session:.eJwVzDEOgCAQRNG7bO0muyOoy2UMAoWxw2BjvLvQTF4x-S-lVuve7tKnnZkCZVEVD-GcLLETr2yIkRFNt2OFMxSa6NL-fXQIQ-gaGQqK2fnl-wG6SBh8.XVNcEA.0NiiN7ldvhokI3sKsstrb0GhOQs']
'''
</code></pre>

<p>（4） flask-session的原理</p>
<p>session 数据保存在 Redis，在Redis中key是session，value是随机字符串，每一个随机字符串对应一个自己的值。每一个用户都会有一个随机字符串。系统将随机字符串返回给用户。</p>
<p>（5）flask-session源码</p>
<pre><code class="py">from flask_session import RedisSessionInterface
</code></pre>

<p>（6）flask-session更多配置</p>
<pre><code class="py">SESSION_TYPE = 'redis'  # 设置session类型
SESSION_REDIS = redis.Redis(host='127.0.0.1', port=6379, password='foobared') # 配置连接redis
SESSION_PERMANENT = True
SESSION_USE_SIGNER = False   # 是否对发送到浏览器上session的cookie值进行加密
SESSION_KEY_PREFIX = 'session:') # 保存到session中的值的前缀
# PERMANENT_SESSION_LIFETIME = datetime.timedelta(days=31)   # session生命周期，保存31天。31天后过期
# PERMANENT_SESSION_LIFETIME = datetime.timedelta(hours=1)   # 保存1小时
PERMANENT_SESSION_LIFETIME = datetime.timedelta(minutes=30)  # 保存30min
</code></pre>

<h4 id="flasksqlalchemy">Flask之SQLAlchemy</h4>
<blockquote>
<p>@[toc]</p>
</blockquote>
<h6 id="1_5">1. 简介</h6>
<p>SQLAlchemy 是 ORM（对象关系映射）框架，类名对应表名，类中的字段对应数据表的列，对象对应数据表的一行。<strong><code>SQLAlchemy 可以帮助我们使用类和对象快速实现数据库操作</code></strong>。我们在公司里要么是用原生sql，要么是用ORM框架。原生 SQL 中可以用 MySQLdb 和 pymysql 模块，MySQLdb 的用法和 pymysql 基本上是完全一样的。两者在使用上是有区别的，<strong><code>MySQLdb不支持python3，pymysql 支持 python2 和 python3</code></strong>。对于Python Web框架，如果有自己的使用自己的，如果没有ORM一般都用SQLAlchemy。</p>
<h6 id="2-curd">2. CURD</h6>
<p>① 创建一个数据表</p>
<p><kbd>models.py</kbd>：</p>
<pre><code class="py"># coding:utf-8
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, Text, Date, DateTime
from sqlalchemy import create_engine
Base = declarative_base()

class Users(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String(32), index=True, nullable=False)

engine = create_engine(
    'mysql+pymysql://root:123456@127.0.0.1:3306/sqlalchemy_test?charset=utf8',
    max_overflow=0,  # 超过连接池大小外最多创建的连接
    pool_size=5,  # 连接池大小
    pool_timeout=30,  # 连接池中没有连接最多等待的时间，否则会报错，30s
    pool_recycle=-1,  # 多久之后对线程池中的线程中进行一次连接的回收（重置）-1表示不重置
)
# Base.metadata.drop_all(engine)#删除这个数据表
Base.metadata.create_all(engine)  # 创建这个数据表
</code></pre>

<p><kbd>users表</kbd>：</p>
<pre><code class="sql">+-------+-------------+------+-----+---------+----------------+
| Field | Type        | Null | Key | Default | Extra          |
+-------+-------------+------+-----+---------+----------------+
| id    | int(11)     | NO   | PRI | NULL    | auto_increment |
| name  | varchar(32) | NO   | MUL | NULL    |                |
+-------+-------------+------+-----+---------+----------------+
</code></pre>

<p>注意：SQLAlchemy默认是不可以修改创建好的数据表的，需要用到第三方组件</p>
<p>② 封装操作：防止models.py被导入的时候执行，把创建表和删除表封装在函数中</p>
<pre><code class="py"># coding:utf-8
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, Text, Date, DateTime
from sqlalchemy import create_engine

Base = declarative_base()

class Users(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String(32), index=True, nullable=False)

def create_all():
    engine = create_engine(
        'mysql+pymysql://root:123456@127.0.0.1:3306/sqlalchemy_test?charset=utf8',
        max_overflow=0,  # 超过连接池大小外最多创建的连接
        pool_size=5,  # 连接池大小
        pool_timeout=30,  # 连接池中没有连接最多等待的时间，否则会报错，30s
        pool_recycle=-1,  # 多久之后对线程池中的线程中进行一次连接的回收（重置）-1表示不重置
    )
    Base.metadata.create_all(engine)  # 创建这个数据表

def drop_all():
    engine = create_engine(
        'mysql+pymysql://root:123456@127.0.0.1:3306/sqlalchemy_test?charset=utf8',
        max_overflow=0,  # 超过连接池大小外最多创建的连接
        pool_size=5,  # 连接池大小
        pool_timeout=30,  # 连接池中没有连接最多等待的时间，否则会报错，30s
        pool_recycle=-1,  # 多久之后对线程池中的线程中进行一次连接的回收（重置）-1表示不重置
    )
    Base.metadata.drop_all(engine)  # 删除这个数据表
if __name__ == '__main__':
    pass
    # create_all()
    # drop_all()
</code></pre>

<p>③ 添加数据</p>
<pre><code class="py">from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import Users

engine = create_engine(
    'mysql+pymysql://root:123456@127.0.0.1:3306/sqlalchemy_test?charset=utf8',
    max_overflow=0,  # 超过连接池大小外最多创建的连接
    pool_size=5,  # 连接池大小
    pool_timeout=30,  # 连接池中没有连接最多等待的时间，否则会报错，30s
    pool_recycle=-1,  # 多久之后对线程池中的线程中进行一次连接的回收（重置）-1表示不重置
)
SessionFactory = sessionmaker(bind=engine)
'''
根据Users类对users表进行增删改查
'''
session = SessionFactory()  # 创建一个连接
'''
增加单条数据
'''
# obj = Users(name='thanlon')
# session.add(obj)
'''
添加多条数据
'''
# obj = Users(name='thanlon')
# obj2 = Users(name='kiku')
# session.add(obj)
# session.add(obj2)
'''
添加多条数据的时候也可以把这些对对象放在列表中
'''
session.add_all([
    Users(name='thanlon'),
    Users(name='kiku')
])

session.commit()
session.close()
</code></pre>

<p>④ 查询数据</p>
<pre><code class="py">from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import Users

engine = create_engine(
    'mysql+pymysql://root:123456@127.0.0.1:3306/sqlalchemy_test?charset=utf8',
    max_overflow=0,  # 超过连接池大小外最多创建的连接
    pool_size=5,  # 连接池大小
    pool_timeout=30,  # 连接池中没有连接最多等待的时间，否则会报错，30s
    pool_recycle=-1,  # 多久之后对线程池中的线程中进行一次连接的回收（重置）-1表示不重置
)
SessionFactory = sessionmaker(bind=engine)
'''
根据Users类对users表进行增删改查
'''
session = SessionFactory()  # 创建一个连接
'''
查询表中所有内容
'''
# ret = session.query(Users).all()
# # print(ret)#拿到的是对象
# # [&lt;models.Users object at 0x7f9cc4ca1080&gt;, &lt;models.Users object at 0x7f9cc4ca10f0&gt;, &lt;models.Users object at 0x7f9cc4ca1160&gt;, &lt;models.Users object at 0x7f9cc4ceee80&gt;, &lt;models.Users object at 0x7f9cc4cf50f0&gt;, &lt;models.Users object at 0x7f9cc4cf5160&gt;]
# for row in ret:
#     print(row.id)
#     print(row.name)
'''
根据条件查询
'''
# ret = session.query(Users).filter(Users.id &gt; 3)  # filter中直接加表达式
# for row in ret:
#     print(row.id, row.name)
#     '''
#     4 kiku
#     5 thanlon
#     6 kiku
#     '''
'''
根据条件查询,拿到第一条数据
'''
ret = session.query(Users).filter(Users.id &gt; 3).first()  # filter中直接加表达式
print(ret.id, ret.name)
'''
4 kiku
'''
session.commit()
session.close()
</code></pre>

<p>⑤ 删除数据</p>
<pre><code class="py">from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import Users

engine = create_engine(
    'mysql+pymysql://root:123456@127.0.0.1:3306/sqlalchemy_test?charset=utf8',
    max_overflow=0,  # 超过连接池大小外最多创建的连接
    pool_size=5,  # 连接池大小
    pool_timeout=30,  # 连接池中没有连接最多等待的时间，否则会报错，30s
    pool_recycle=-1,  # 多久之后对线程池中的线程中进行一次连接的回收（重置）-1表示不重置
)
SessionFactory = sessionmaker(bind=engine)
session = SessionFactory()  # 创建一个连接
'''
删除数据
'''
# session.query(Users).delete()
session.query(Users).filter(Users.id &gt; 3).delete()
session.commit()
</code></pre>

<p>⑥ 修改数据</p>
<pre><code class="py">from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import Users

engine = create_engine(
    'mysql+pymysql://root:123456@127.0.0.1:3306/sqlalchemy_test?charset=utf8',
    max_overflow=0,  # 超过连接池大小外最多创建的连接
    pool_size=5,  # 连接池大小
    pool_timeout=30,  # 连接池中没有连接最多等待的时间，否则会报错，30s
    pool_recycle=-1,  # 多久之后对线程池中的线程中进行一次连接的回收（重置）-1表示不重置
)
SessionFactory = sessionmaker(bind=engine)
session = SessionFactory()  # 创建一个连接
'''
修改数据
'''
# session.query(Users).filter(Users.id == 1).update({Users.name: 'liuyuqin'})
# session.query(Users).filter(Users.id == 1).update({'name': Users.name + 'hello'}, synchronize_session=False)#等效于下面的
session.query(Users).filter(Users.id == 1).update({Users.name: Users.name + 'hello'}, synchronize_session=False)
session.commit()
</code></pre>

<h6 id="3_2">3. 常用操作</h6>
<p>① 指定列</p>
<pre><code class="py">ret = session.query(Users.id, Users.name.label('cname')).all()
for item in ret:
    print(item, type(item), item[0], item.id, item.cname)
    # item是&lt;class 'sqlalchemy.util._collections.result'&gt;,打印的是元组，实际不是元组类型，但可以通过元组去值。能够通过索引去取，说明该类中有__item__方法
query = session.query(Users.id, Users.name.label('cname'))  # query的值就是sql语句
</code></pre>

<p>② 1. 默认条件是and</p>
<pre><code class="py">session.query(Users).filter(Users.id == 1, Users.name == 'thanlon').all()
</code></pre>

<p>③ between</p>
<pre><code class="py">session.query(Users).filter(Users.id.between(1, 2), Users.name == 'thanlon').all()
</code></pre>

<p>④ in</p>
<pre><code class="py"> session.query(Users).filter(Users.id.in_([1, 2, 3])).all()
session.query(Users).filter(~Users.id.in_([1, 2, 3])).all()
</code></pre>

<p>⑤ 子查询</p>
<pre><code class="py">session.query(Users).filter(Users.id.in_(session.query(Users.id).filter(Users.name == 'thanlon'))).all()
</code></pre>

<p>⑥ and和or</p>
<pre><code class="py">from sqlalchemy import and_, or_

session.query(Users).filter(and_(Users.id &gt; 1, Users.name == 'thanlon')).all()  # 没有and_也是一样的表示and
session.query(Users).filter(or_(Users.id &gt; 1, Users.name == 'thanlon')).all()  # 或者
session.query(Users).filter(
    or_(Users.id &gt; 1, and_(Users.name == 'thanlon', Users.id &gt; 3))
).all()
</code></pre>

<p>⑦ filter_by</p>
<pre><code class="py">session.query(Users).filter_by(name='thanlon').all()  # 条件，内部也是使用filter
</code></pre>

<p>⑧ 通配符</p>
<pre><code class="py">session.query(Users).filter(Users.name.like('t_')).all()  # t后面有一个字符
session.query(Users).filter(~Users.name.like('t%')).all()  # 以t开头
</code></pre>

<p>⑨ 切片/分页</p>
<pre><code class="py">session.query(Users)[1, 3]
</code></pre>

<p>排序：</p>
<pre><code class="py">session.query(Users).order_by(Users.name.desc()).all()  # 按照姓名从大到小
session.query(Users).order_by(Users.name.desc(), Users.id.asc()).all()  # 先按照name从大到小排列，如果同名按照id升序排列
</code></pre>

<p>分组：</p>
<pre><code class="py">from sqlalchemy.sql import func

'''
第一种情况
'''
# ret = session.query(func.max(Users.id)).group_by(Users.depart_id).all()
# for item in ret:
#     print(item)
'''
第二种情况
'''
# ret = session.query(func.min(Users.id)).group_by(Users.depart_id).all()
# for item in ret:
#     print(item)
'''
第三种情况
'''
# ret = session.query(Users.depart_id,func.count(Users.id)).group_by(Users.depart_id).all()
# for item in ret:
#     print(item)
#     '''
#     (1, 2)
#     (2, 1)
#     '''
'''
第四种情况:根据聚合条件二次筛选用having(部门人数大于等于2)
'''
ret = session.query(Users.depart_id, func.count(Users.id)).group_by(Users.depart_id).having(
    func.count(Users.id) &gt;= 2).all()
for item in ret:
    print(item)
    '''
    (1, 2)
    '''
# 注意：如果使用group，根据聚合的结果进行二次筛选时，只能用having
</code></pre>

<p>组合：将两个表上下拼接(union和union all)，而join是左右拼接</p>
<pre><code class="py">'''
union：不会去重
'''
# q = session.query(Users.name).filter(Users.id &gt; 0)
# q2 = session.query(Admin.admin_name).filter(Admin.id &gt; 0)
# ret = q.union(q2).all()
# for item in ret:
#     print(item.name)
'''
union：去重
'''
q = session.query(Users.name).filter(Users.id &gt; 0)
q2 = session.query(Admin.admin_name).filter(Admin.id &gt; 0)
ret = q.union_all(q2).all()
for item in ret:
    print(item.name)
</code></pre>

<h6 id="4_1">4. 外键操作</h6>
<p>① 创建两个表，注意Users表中是加了外键的</p>
<pre><code class="py">class Depart(Base):
    __tablename__ = 'depart'
    id = Column(Integer, primary_key=True)
    title = Column(String(32), index=True, nullable=False)

class Users(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String(32), index=True, nullable=False)
    depart_id = Column(Integer, ForeignKey('depart.id'))  # depart小写代表表名，不是类名
</code></pre>

<p>插入数据：</p>
<pre><code class="sql">mysql&gt; insert depart values(null,'technology');
mysql&gt; insert depart values(null,'develop');
mysql&gt; insert users values(null,'thanlon',1);
mysql&gt; insert users values(null,'yuqin',2);
</code></pre>

<p>② 外键操作：
我们在这里可以查询所有用户的信息和所属部门名称，具体操作如下：</p>
<pre><code class="py"># ret = session.query(Users, Depart).join(Depart).all()  #depart_id = Column(Integer, ForeignKey('depart.id')),默认根据depart.id等效于下面的
ret = session.query(Users, Depart).join(Depart, Users.depart_id == Depart.id).all()  # on的条件是:depart_id == Depart.id
for row in ret:
    print(row[0].id, row[0].name, row[1].title)
</code></pre>

<p>也可以指定要查询的具体内容，</p>
<pre><code class="py"># 也可以指定获取指定的内容
ret = session.query(Users.id, Users.name, Depart.title.label('as_title')).join(Depart,
                                                                               Users.depart_id == Depart.id).all()
for row in ret:
    print(row.id, row.name, row.as_title)
</code></pre>

<p>可以使用多个join，但只有左连接没有右连接的概念，右连接是没有意义的。此外，下面query变量打印出来是一个sql语句，query变量的类型是：<kbd><class 'sqlalchemy.orm.query.Query'></kbd>。</p>
<pre><code class="py">query = session.query(Users.id, Users.name, Depart.title).join(Depart, Users.depart_id == Depart.id,
                                                               isouter=True)  # 没有right join是没有意义的
</code></pre>

<p>我们把在对应users的Users类中添加一个dp字段，注意这个字段不会在表中存在，只有Column实例化的对象才会对应数据表中的列。<strong><code>加入relationship可以帮助我们(跨表)做关联查询和创建关联数据。</code></strong></p>
<pre><code class="py">from sqlalchemy.orm import relationship
class Users(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String(32), index=True, nullable=False)
    depart_id = Column(Integer, ForeignKey('depart.id'))  # depart小写代表表名，不是类名
    dp = relationship('Depart',backref = 'pers')
</code></pre>

<p>比如上面的“查询所有用户的信息和所属部门名称”可以这样操作：</p>
<pre><code class="py">ret = session.query(Users).all()
print(ret)  # [&lt;models.Users object at 0x7f5b935bb7f0&gt;, &lt;models.Users object at 0x7f5b935bb860&gt;……]
for row in ret:
    print(row.id, row.name, row.depart_id, row.dp.title)
</code></pre>

<p>还可以反向跨表，比如查询销售部为“develop”的所有人员，我们可以这样操作：</p>
<pre><code class="py">obj = session.query(Depart).filter(Depart.title == 'develop').first()
print(obj.pers)  # [&lt;models.Users object at 0x7fef08122160&gt;]
for row in obj.pers:
    print(row.id, row.name, obj.title)
</code></pre>

<p>上面两个例子是使用表示relationship可以做关联查询，下面的例子则会介绍一次性创建关联数据。
比如有这样的需求“创建一个名称是‘finance’的部门并在该部门中添加员工：thanlon”,一般情况下我们是这样操作的：</p>
<pre><code class="py">dp = Depart(title='finance')
session.add(dp)
session.commit()
#再根据根据finance部门id创建员工
u = Users(name='thanlon', depart_id=dp.id)
session.add(u)
session.commit()
</code></pre>

<p>上面是一种方式，有了relationship，我们可以这样创建：</p>
<pre><code class="py">u = Users(name='thanlon', dp=Depart(title='finance'))
session.add(u)
session.commit()
</code></pre>

<p>可以看到简单多了吧!
问题来了，如果创建一个部门再在这个部门创建多个员工，如果按照上面的例子，会又创建若干个finance部门。当然，如果按照上上个例子一个个添加员工也是可以的。但是，我们还有简便的方式，你可以这样做：</p>
<pre><code class="py"># 创建一个部门，添加多个员工
dp = Depart(title='finance')
dp.pers = [
    Users(name='a'),
    Users(name='b'),
    Users(name='c')
]
session.add(dp)
session.commit()
</code></pre>

<h6 id="5_2">5. 多对多操作</h6>
<p>① 多对多表的创建</p>
<p>创建学生表、课程表和中间表(部分代码省略)</p>
<pre><code class="py">from sqlalchemy import Column, Integer, String, Text, Date, DateTime, ForeignKey, UniqueConstraint, Index

class Student(Base):
    __tablename__ = 'student'
    id = Column(Integer, primary_key=True)
    name = Column(String(32), index=True, nullable=False)

class Course(Base):
    __tablename__ = 'course'
    id = Column(Integer, primary_key=True)
    title = Column(String(32), index=True, nullable=False)

class Student2Course(Base):
    __tablename__ = 'student2course'
    id = Column(Integer, primary_key=True, autoincrement=True)
    student_id = Column(Integer, ForeignKey('student.id'))
    course_id = Column(Integer, ForeignKey('course.id'))
    __table_args__ = (
        UniqueConstraint('student_id', 'course_id', name='uc_student_course'),  # 联合唯一索引
        # Index('i_student_course', 'student_id', 'course_id')#联合索引
    )
</code></pre>

<p>② 添加数据</p>
<p>添加Student表和Course表数据：</p>
<pre><code class="py">session.add_all([
    Student(name='thanlon'),
    Student(name='Aurora'),
    Student(name='kiku'),
    Course(title='English'),
    Course(title='Computer'),
])
session.commit()
</code></pre>

<p>添加中间表数据：</p>
<pre><code class="py">session.add_all([
    Student2Course(student_id=4,course_id=1),
    Student2Course(student_id=4,course_id=2),
])
session.commit()
</code></pre>

<pre><code class="py">session.add_all([
    Student2Course(student_id=5,course_id=1),
])
session.commit()
</code></pre>

<pre><code class="py">session.add_all([
    Student2Course(student_id=6,course_id=2),
])
session.commit()
</code></pre>

<p>③ 多对多操作</p>
<p>操作1：查询学生姓名和对应的选课课程名（三张表关联查询）</p>
<pre><code class="py">from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import Users, Depart, Student, Course, Student2Course

engine = create_engine(
    'mysql+pymysql://root:123456@127.0.0.1:3306/sqlalchemy_test?charset=utf8',
    max_overflow=0,  # 超过连接池大小外最多创建的连接
    pool_size=5,  # 连接池大小
    pool_timeout=30,  # 连接池中没有连接最多等待的时间，否则会报错，30s
    pool_recycle=-1,  # 多久之后对线程池中的线程中进行一次连接的回收（重置）-1表示不重置
)
SessionFactory = sessionmaker(bind=engine)
session = SessionFactory()
ret = session.query(Student2Course.id, Student.name, Course.title).join(Student,
                                                                        Student2Course.student_id == Student.id,
                                                                        isouter=True).join(
    Course, Student2Course.course_id == Course.id, isouter=True).order_by(Student2Course.id.asc())
for row in ret:
    print(row)
    '''
    (1, 'thanlon', 'English')
    (2, 'thanlon', 'Computer')
    (3, 'Aurora', 'English')
    (4, 'kiku', 'Computer')
    '''
session.close()
</code></pre>

<p>操作2：学生“thanlon”选的所有课</p>
<pre><code class="py">……
ret = session.query(Student2Course.id, Student.name, Course.title).join(Student,
                                                                        Student2Course.student_id == Student.id,
                                                                        isouter=True).join(
    Course, Student2Course.course_id == Course.id, isouter=True).filter(Student.name == 'Thanlon').order_by(
    Student2Course.id.asc()).all()
print(ret)
# [(1, 'thanlon', 'English'), (2, 'thanlon', 'Computer')]
……
</code></pre>

<p>上面两个例子是一般多对关联查询操作，下面使用relationship，首先需要修改建Student表语句：</p>
<p><kbd>model.py</kbd>：</p>
<pre><code class="py">class Student(Base):
    __tablename__ = 'student'
    id = Column(Integer, primary_key=True)
    name = Column(String(32), index=True, nullable=False)
    course_list = relationship('Course', secondary='student2course', backref='student_list')  # 根据与Course做关联
</code></pre>

<p>使用relationship来查询来执行操作2：学生“thanlon”选的所有课，可以这样：</p>
<pre><code class="py">obj = session.query(Student).filter(Student.name == 'thanlon').first()
for item in obj.course_list:
    print(item.title)
    '''
    Computer
    English
    '''
</code></pre>

<p>除了使用relationship正向查找，还可以反向查找，比如：查找选择“Computer”的所有人，</p>
<pre><code class="py">obj = session.query(Course).filter(Course.title == 'computer').first()
# print(obj)#&lt;models.Course object at 0x7fe264215668&gt;
for item in obj.student_list:
    print(item.name)
    '''
    thanlon
    kiku
    '''
</code></pre>

<p>操作3：插入数据示例，需求“创建一个课程，创建两个学生，两个学生选新创建的课程”
这里使用relationship，</p>
<pre><code class="py">obj = Course(title='math')
obj.student_list = [Student(name='Maria'), Student(name='Michael')]
session.add(obj)#在course表增加数据，在student表增加两条数据，在中间关系表中增加两条
session.commit()
</code></pre>

<h6 id="6_1">6. 两种连接数据库的方式</h6>
<p>① 自己实例化session对象</p>
<pre><code class="py">from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import Users
from threading import Thread

engine = create_engine(
    'mysql+pymysql://root:123456@127.0.0.1:3306/sqlalchemy_test?charset=utf8',
    max_overflow=0,  # 超过连接池大小外最多创建的连接
    pool_size=5,  # 连接池大小
    pool_timeout=30,  # 连接池中没有连接最多等待的时间，否则会报错，30s
    pool_recycle=-1,  # 多久之后对线程池中的线程中进行一次连接的回收（重置）-1表示不重置
)
SessionFactory = sessionmaker(bind=engine)

def task():
    # 去连接池获取一个连接
    session = SessionFactory()
    ret = session.query(Users).all()
    # 将连接交给连接池
    session.close()

if __name__ == '__main__':
    t = Thread(target=task)
    t.start()
</code></pre>

<p>如果用同一个连接，多线程请求数据时，这个连接很可能忙不过来，数据很有可能出现混乱。所以，实例化session对象(创建一个连接)的代码是不可以放在task函数外面(全局)。此外，<kbd>session.close()</kbd>会把仅有的一个连接释放，其它线程是不可以用到的，因为这种情况下连接只创建了一次。</p>
<pre><code class="py">from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import Users
from threading import Thread

engine = create_engine(
    'mysql+pymysql://root:123456@127.0.0.1:3306/sqlalchemy_test?charset=utf8',
    max_overflow=0,  # 超过连接池大小外最多创建的连接
    pool_size=5,  # 连接池大小
    pool_timeout=30,  # 连接池中没有连接最多等待的时间，否则会报错，30s
    pool_recycle=-1,  # 多久之后对线程池中的线程中进行一次连接的回收（重置）-1表示不重置
)
SessionFactory = sessionmaker(bind=engine)

# 去连接池获取一个连接
session = SessionFactory()

def task():
    ret = session.query(Users).all()
    # 将连接交给连接池
    session.close()

if __name__ == '__main__':
    t = Thread(target=task)
    t.start()
</code></pre>

<p>② 通过Threading.Local实现的(推荐使用)
基于Threading.Local也是为每个线程获取一个连接。</p>
<pre><code class="py">from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import Users
from threading import Thread
from sqlalchemy.orm import scoped_session

engine = create_engine(
    'mysql+pymysql://root:123456@127.0.0.1:3306/sqlalchemy_test?charset=utf8',
    max_overflow=0,  # 超过连接池大小外最多创建的连接
    pool_size=5,  # 连接池大小
    pool_timeout=30,  # 连接池中没有连接最多等待的时间，否则会报错，30s
    pool_recycle=-1,  # 多久之后对线程池中的线程中进行一次连接的回收（重置）-1表示不重置
)
SessionFactory = sessionmaker(bind=engine)
# 去连接池获取一个连接
session = scoped_session(SessionFactory)

def task():
    ret = session.query(Users).all()
    # 将连接交给连接池
    session.remove()

if __name__ == '__main__':
    t = Thread(target=task)
    t.start()
</code></pre>

<h6 id="7-sql">7. 原生SQL</h6>
<p>Django里面可以执行原生SQL，SQLAlchemy也可以执行原生SQL，如果SQL语句比较复杂，ORM解决不了，那么可以使用原生SQL。SQLAlchemy 执行原生 SQL的 方式有好多种，在这里介绍其中两种。</p>
<p><strong><code>方式1</code></strong>：</p>
<pre><code class="py">from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import Users
from threading import Thread
from sqlalchemy.orm import scoped_session

engine = create_engine(
    'mysql+pymysql://root:123456@127.0.0.1:3306/sqlalchemy_test?charset=utf8',
    max_overflow=0,  # 超过连接池大小外最多创建的连接
    pool_size=5,  # 连接池大小
    pool_timeout=30,  # 连接池中没有连接最多等待的时间，否则会报错，30s
    pool_recycle=-1,  # 多久之后对线程池中的线程中进行一次连接的回收（重置）-1表示不重置
)
SessionFactory = sessionmaker(bind=engine)
# 去连接池获取一个连接
session = scoped_session(SessionFactory)

def task():
    '''
    方式1
    '''
    # 查询
    # cursor = session.execute('select *from users')
    # ret = cursor.fetchall()
    # 插入
    cursor = session.execute('insert users(name) values(:value)', params={'value': 'thanlon'})
    session.commit()
    print(cursor.lastrowid)

if __name__ == '__main__':
    t = Thread(target=task)
    t.start()
</code></pre>

<p><strong><code>方式2</code></strong>：</p>
<pre><code class="py">from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import Users
from threading import Thread
from sqlalchemy.orm import scoped_session

engine = create_engine(
    'mysql+pymysql://root:123456@127.0.0.1:3306/sqlalchemy_test?charset=utf8',
    max_overflow=0,  # 超过连接池大小外最多创建的连接
    pool_size=5,  # 连接池大小
    pool_timeout=30,  # 连接池中没有连接最多等待的时间，否则会报错，30s
    pool_recycle=-1,  # 多久之后对线程池中的线程中进行一次连接的回收（重置）-1表示不重置
)
SessionFactory = sessionmaker(bind=engine)
# 去连接池获取一个连接
session = scoped_session(SessionFactory)

def task():
    '''
    方式2
    '''
    conn = engine.raw_connection()
    cursor = conn.cursor()
    cursor.execute(
        'select *from users'
    )
    ret = cursor.fetchall()
    print(ret)  # ((1, 'liuyuqinhellohello'), (2, 'thanlon'), (3, 'thanlon'), (7, 'thanlon'))
    cursor.close()
    conn.close()

if __name__ == '__main__':
    t = Thread(target=task)
    t.start()
</code></pre>

<h4 id="pipreqs">pipreqs组件</h4>
<blockquote>
<p>@[toc]</p>
</blockquote>
<h6 id="1-pipreqs">1. pipreqs的安装</h6>
<p>pipreqs 组件可以帮助我们找到项目中使用到的所有依赖库及其对应的版本信息并自动保存为 <strong><code>requirements.txt</code></strong> 文件，与我们一般使用的 <strong><code>pip freeze &gt; xxx.txt</code></strong> 命令具有相同的功能。<strong><code>requirements.txt</code></strong> 文件可以被 PyCharm 识别，会提示我们安装依赖库。应用之前需要安装：</p>
<pre><code class="py">$ pip install pipreqs -i https://mirrors.aliyun.com/pypi/simple
</code></pre>

<blockquote>
<p><strong><code>pipreqs是第三方组件(库)，Flask和Django中都可以使用！</code></strong></p>
</blockquote>
<h6 id="2-pipreqs">2. pipreqs的应用</h6>
<p>在项目目录下执行 <strong><code>pipreqs ./</code></strong>，就会在当前目录生成 <strong><code>requirements.txt</code></strong> 文件：</p>
<pre><code class="py">$ pipreqs ./
INFO: Successfully saved requirements file in ./requirements.txt
</code></pre>

<p>有的电脑是 unicode 编码，有的是 gbk (windows)。如果遇到编码错误，需要指定编码：</p>
<pre><code class="py">$ pipreqs ./ --encoding=utf-8
</code></pre>

<p>生成的 <strong><code>requirements.txt</code></strong> 可以通过 <strong><code>pip install -r requirements.txt</code></strong> 命令来安装依赖库。</p>
<h4 id="flask-script">Flask-Script组件</h4>
<blockquote>
<p>@[toc]</p>
</blockquote>
<h6 id="1-flask-script">1. 安装Flask-Script</h6>
<pre><code class="py">$ pip install flask-script -i https://mirrors.aliyun.com/pypi/simple
</code></pre>

<h6 id="2_7">2. 命令的方式启动项目</h6>
<p>Flask-Script 使用命令的方式启动 Flask 项目：</p>
<p><strong><code>manage.py:</code></strong></p>
<pre><code class="py">from app import create_app
from flask_script import Manager

app = create_app()
manager = Manager(app)
if __name__ == '__main__':
    # app.run(port=5051)
    manager.run()
</code></pre>

<p>在项目目录下执行下面的命令，还可以指定 IP 和端口：</p>
<pre><code class="py">$ python manage.py runserver
$ python manage.py runserver -h 127.0.0.1
$ python manage.py runserver -h 127.0.0.1 -p 5051
</code></pre>

<h6 id="3_3">3. 定制命令</h6>
<p>（1）通过 <strong><code>位置传参</code></strong> 定制命令：</p>
<pre><code class="py">from app import create_app
from flask_script import Manager

app = create_app()
manager = Manager(app)

@manager.command
def custom(arg):
    &quot;&quot;&quot;
    自定义命令
    :return:
    &quot;&quot;&quot;
    print(arg)

if __name__ == '__main__':
    # app.run(port=5051)
    manager.run()
</code></pre>

<pre><code class="py">$ python manage.py custom 123456
123456
</code></pre>

<blockquote>
<p><strong><code>可以把创建表的离线脚本写到函数中，运行的时候创建表。</code></strong></p>
</blockquote>
<p>（2）通过 <strong><code>关键字传参</code></strong> 定制下面的命令：</p>
<pre><code class="py">from app import create_app
from flask_script import Manager

app = create_app()
manager = Manager(app)

@manager.command
def custom(arg):
    &quot;&quot;&quot;
    自定义命令
    :return:
    &quot;&quot;&quot;
    print(arg)

@manager.option('-n', '--name', dest='name')
@manager.option('-u', '--url', dest='url')
def cmd(name, url):
    print(name, url)

if __name__ == '__main__':
    # app.run(port=5051)
    manager.run()
</code></pre>

<pre><code class="py">$ python manage.py cmd -n erics -u https://www.erics1996.com
erics https://www.erics1996.com
</code></pre>

<h6 id="4-flask-script">4. Flask-Script应用</h6>
<p>离线脚本做一些操作时可以通过自定制命令来执行，比如执行导入用户名密码、敏感字符到 excel 的离线脚本等操作。</p>
<h4 id="flask-migrate">Flask-Migrate数据库迁移组件</h4>
<blockquote>
<p>@[toc]</p>
</blockquote>
<p>Flask-Migrate 可以做 <strong><code>数据库迁移</code></strong>，与Django中数据迁移功能相同。Flask-Migrate 依赖于 flask_script 来执行命令：</p>
<p><strong><code>manage.py:</code></strong></p>
<pre><code class="py">from app import create_app
from flask_script import Manager
from flask_migrate import Migrate, MigrateCommand
from app import db

app = create_app()
manager = Manager(app)
Migrate(app, db)
manager.add_command('db', MigrateCommand)
&quot;&quot;&quot;
数据库迁移命令：
python manage.py db init
python manage.py db migrate # 相当于Django中makemigrations
python manage.py db upgrade # 相当于Django中的migrate
&quot;&quot;&quot;
if __name__ == '__main__':
    manager.run()
    # app.run(port=5051)
</code></pre>

<p>在项目目录下执行数据库迁移命令：</p>
<pre><code class="py">$ python manage.py db init
$ python manage.py db migrate
$ python manage.py db upgrade
</code></pre>

<blockquote>
<p><strong><code>执行迁移操作之前需要保证 models.py 中有写表对应的类，也要确保把导入 model.py，即 import app.models 或 from app.models import *</code></strong></p>
</blockquote>
<h4 id="flask-sqlalchemy">Flask-SQLALchemy组件</h4>
<blockquote>
<p>@[toc]</p>
</blockquote>
<h6 id="1-flask-sqlalchemy">1. 安装Flask-SQLALchemy</h6>
<pre><code class="py">$ pip install flask-sqlalchemy -i https://mirrors.aliyun.com/pypi/simple
</code></pre>

<h6 id="2-flask-sqlalchemy">2. 使用Flask-SQLALchemy</h6>
<p><strong><code>__init__.py:</code></strong></p>
<pre><code class="py">from flask import Flask
from flask_session import Session
from flask_sqlalchemy import SQLAlchemy

&quot;&quot;&quot;
第一步：实例化SQLAlchemy
&quot;&quot;&quot;
db = SQLAlchemy()

from app.admin import admin as admin_blueprint
from app.home import home as home_blueprint

from .models import *


def create_app():
    app = Flask(__name__)
    app.config.from_object('settings.DevelopmentConfig')
    app.register_blueprint(admin_blueprint)
    app.register_blueprint(home_blueprint)
    Session(app)
    &quot;&quot;&quot;
    第二步：初始化，读配置文件
    &quot;&quot;&quot;
    # 缺少数据库连接，把数据库连接配置传到sqlalchemy，
    db.init_app(app)  # init_app方法源码可以查看已有的配置
    return app
</code></pre>

<blockquote>
<p><strong><code>注意实例化SQLAlchemy必须在导入蓝图之前，因为蓝图中需要用到db，db必须在导入蓝图之前创建。还有，必须导入models.py才能生成表结构!</code></strong></p>
<p><strong><code>settings.py:</code></strong></p>
</blockquote>
<pre><code class="py">import redis

class BaseConfig(object):
    &quot;&quot;&quot;
    第三步：在配置文件写入配置
    &quot;&quot;&quot;
    SECRET_KEY = '0160a068dba74c5aa21f5b93cc6b95c5'
    # SQLALCHEMY配置
    SQLALCHEMY_DATABASE_URI = 'mysql+pymysql://root:123456@localhost:3306/d5_video?charset=utf8mb4'
    SQLALCHEMY_TRACK_MODIFICATIONS = True
    SQLALCHEMY_POOL_SIZE = 10
    SQLALCHEMY_MAX_OVERFLOW = 10  # 最多超出10个连接
    # Redis配置
    SESSION_TYPE = 'redis'
    SESSION_REDIS = redis.Redis(host='127.0.0.1', port=6379, password='foobared')

class ProductionConfig(BaseConfig):
    DEBUG = False

class DevelopmentConfig(BaseConfig):
    DEBUG = True

class TestingConfig(BaseConfig):
    DEBUG = True
</code></pre>

<p><strong><code>models.py:</code></strong></p>
<pre><code class="py">&quot;&quot;&quot;
第四步：创建与数据库表结构对应的类
&quot;&quot;&quot;
from app import db
from datetime import datetime

# db.Model=make_declarative_base
class Auth(db.Model):
    __tablename__ = &quot;auth&quot;
    __table_args__ = {'extend_existing': True}
    id = db.Column(db.Integer, primary_key=True)  # 编号
    name = db.Column(db.String(100), unique=True)  # 权限名称
    url = db.Column(db.String(255), unique=True)  # 权限名称
    addtime = db.Column(db.DateTime, default=datetime.now)  # 添加时间
</code></pre>

<p><strong><code>create_tables.py:</code></strong></p>
<pre><code class="py">&quot;&quot;&quot;
第五步：创建生成数据表的离线脚本，需要使用到app上下文
&quot;&quot;&quot;
from app import db, create_app

app = create_app()  # from manage import app
app_ctx = app.app_context()  # AppContext对象里面有app和g
&quot;&quot;&quot;
1.去指定的请求上下文中找app,再去app中找配置文件和Models
2.在执行db.create_all()之前，必须先把app和g封装成AppContext对象，然后放到Local中，才就可以取到
3.没有用到应用上下文request/session。app上下文中有app和g，g没有用上，但app用上了！
4.为什么要把上下文管理分为应用上下文request/session和请求上下文app/g?
① Flask的SQLALchemy生成表结构时候用不上应用上下文request/session。
② 如果用到request/session需要传请求，并非http操作，生成表结构只是个离线脚本)
&quot;&quot;&quot;
&quot;&quot;&quot;
__enter__：LocalStack().push()，通过LocalStack把AppContext的对象(app_ctx)放到Local中
&quot;&quot;&quot;
with app_ctx:
    db.create_all()  # 内部会从app_ctx中获取app，再从app中获取配置文件
&quot;&quot;&quot;
__exit__：LocalStack().pop(),通过LocalStack再从Local中移出
&quot;&quot;&quot;
</code></pre>

<p><strong><code>admin.py:</code></strong></p>
<pre><code class="py">from .. import admin
from app import db,models

@admin.route('/admin/')
def index():
    &quot;&quot;&quot;
    添加数据，如果没有连接db.session(create_scoped_session)内部会自动创建连接
    &quot;&quot;&quot;
    db.session.add(models.Auth(name='',url=''))
    db.session.commit()
    # 释放连接
    db.session.remove()
    &quot;&quot;&quot;
    查询数据
    &quot;&quot;&quot;
    ret = db.session.query(models.Auth).all()
    print(ret)
    db.session.remove()
    return 'index'
</code></pre>

<h6 id="3_4">3. 源码相关图示</h6>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200714055240749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" />
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200714055354520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" />
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/202007140604298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" />
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200714060509650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" />
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200714060616799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" />
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200714060622541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" />
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200714155629805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" />
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200714155735868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" />
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20200714155727684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoYW5sb24=,size_16,color_FFFFFF,t_70" />
<hr></p>
<h4 id="flask_8">Flask简单登录案例</h4>
<blockquote>
<p>@[toc]</p>
</blockquote>
<h6 id="1_6">1. 案例目录结构</h6>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190617090517640.jpg" /></p>
<h6 id="2_8">2. 案例主要代码</h6>
<p><strong><code>app.py：</code></strong></p>
<pre><code class="python">from flask import Flask, render_template, request, redirect, session

# app = Flask(__name__, static_folder='static', static_url_path='/thanlon')  # 可指定前缀
app = Flask(__name__)
app.secret_key = 'thanlon'


@app.route('/login', methods=['GET', 'POST'])  # 默认允许GET请求
def login():
    if request.method == 'GET':
        return render_template('login.html')
    username = request.form.get('username')
    pwd = request.form.get('pwd')
    if username == 'Thanlon' and pwd == '123':
        session['username'] = username  # 默认session保存在签名或加密的cookie中
        return redirect('/index')
    # return render_template('login.html', error='用户名或者密码错误！')
    return render_template('login.html', **{'error': '用户名或者密码错误！'})


@app.route('/index')  # 默认允许GET请求
def index():
    username = session.get('username')
    if not username:
        return redirect('/login')
    return render_template('index.html')


if __name__ == '__main__':
    app.run()
</code></pre>

<p><strong><code>login.html：</code></strong></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
    &lt;title&gt;登录&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot;
          integrity=&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot; crossorigin=&quot;anonymous&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;row&quot; style=&quot;margin-top:30px&quot;&gt;
        &lt;div class=&quot;col-md-4 col-md-offset-4&quot;&gt;
            &lt;div class=&quot;panel panel-primary&quot;&gt;
                &lt;div class=&quot;panel-heading&quot;&gt;登录&lt;/div&gt;
                &lt;div class=&quot;panel-body&quot;&gt;
                    &lt;form method=&quot;POST&quot;&gt;
                        &lt;div class=&quot;form-group&quot;&gt;
                            &lt;label&gt;用户名&lt;/label&gt;
                            &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; id=&quot;&quot; placeholder=&quot;Username&quot;
                                   required=&quot;required&quot;&gt;
                        &lt;/div&gt;
                        &lt;div class=&quot;form-group&quot;&gt;
                            &lt;label&gt;密码&lt;/label&gt;
                            &lt;input type=&quot;password&quot; name=&quot;pwd&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot;
                                   required=&quot;required&quot;&gt;
                            &lt;div style=&quot;color:red&quot;&gt;{{error}}&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;登录&lt;/button&gt;
                    &lt;/form&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js&quot;
        integrity=&quot;sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa&quot;
        crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>

<p><strong><code>index.html：</code></strong></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
    &lt;title&gt;首页&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot;
          integrity=&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot; crossorigin=&quot;anonymous&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;row&quot; style=&quot;margin-top:30px&quot;&gt;
        &lt;div class=&quot;panel panel-default&quot;&gt;
            &lt;div class=&quot;panel-body&quot;&gt;
                欢迎{{session['username']}}进入首页！
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js&quot;
        integrity=&quot;sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa&quot;
        crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>

<hr>

<h4 id="flask_9">Flask模板渲染</h4>
<blockquote>
<p>@[toc]</p>
</blockquote>
<h6 id="1_7">1. 数据类型的渲染</h6>
<p>显示列表：</p>
<p><kbd>app.py</kbd></p>
<pre><code class="py">@app.route('/tpl')
def tpl():
    content = {
        'user': ['thanlon', 'kiku']
    }
    return render_template('tpl.html', **content)
</code></pre>

<p><kbd>tpl.html</kbd></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{{ user.0 }}{#支持django的写法#}
{{ user[1] }}{#支持python的写法#}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190810192024323.png" />
显示元组：</p>
<p><kbd>app.py</kbd></p>
<pre><code class="py">@app.route('/tpl')
def tpl():
    content = {
        'user': ('thanlon', 'kiku')
    }
    return render_template('tpl.html', **content)
</code></pre>

<p><kbd>tpl.html</kbd></p>
<pre><code class="py">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{{ user.0 }}
{{ user[1] }}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190810192024323.png" />
显示字符串：</p>
<p><kbd>app.py</kbd>：</p>
<pre><code class="python">@app.route('/tpl')
def tpl():
    content = {
        'txt': '&lt;input type=&quot;text&quot;/&gt;'
    }
    return render_template('tpl.html', **content)
</code></pre>

<p><kbd>tpl.html</kbd>：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{{ txt }}
{{ txt|safe }}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190810192639638.png" />
使用Markup函数：
<kbd>app.py</kbd>：</p>
<pre><code class="py">@app.route('/tpl')
def tpl():
    content = {
        'txt': Markup('&lt;input type=&quot;text&quot;/&gt;')
    }
    return render_template('tpl.html', **content)
</code></pre>

<p><kbd>tpl.html</kbd>：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{{ txt }}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h6 id="2_9">2. 传入函数</h6>
<p><kbd>app.py</kbd>：</p>
<pre><code class="py">def func(arg):
    return arg + 1
@app.route('/tpl')
def tpl():
    content = {
        'func': func
    }
    return render_template('tpl.html', **content)
</code></pre>

<p><kbd>tpl.html</kbd>：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{{ func(1) }}&lt;!--2--&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h6 id="3_5">3. 全局定义函数</h6>
<p>传参的时候自己可以传，全局也可以传参，template_global() 装饰器就是用来传参的。</p>
<p><kbd>app.py</kbd>：</p>
<pre><code class="py">@app.template_global()
def test(a, b):
    # {{ test(1,2) }}
    return a + b

@app.route('/tpl')
def tpl():
    content = {

    }
    return render_template('tpl.html', **content)
</code></pre>

<p><kbd>tpl.html</kbd>：</p>
<pre><code class="py">……
&lt;body&gt;
{{ test(1,2) }}
&lt;/body&gt;
…… 
</code></pre>

<p>template_filter() 装饰器也就是用来传参的，</p>
<p><kbd>app.py</kbd>：</p>
<pre><code class="py">@app.template_filter()
def test(a, b, c):
    # {{ 1|test(2,3) }}
    return a + b + c

@app.route('/tpl')
def tpl():
    content = {

    }
    return render_template('tpl.html', **content)
</code></pre>

<p><kbd>tpl.html</kbd>：</p>
<pre><code class="html">&lt;body&gt;
{{ 1|test(2,3) }}
{% if 1|test(2,3) %}
&lt;/body&gt;
</code></pre>

<p><kbd>template_filter</kbd>与<kbd>template_global</kbd>区别是：template_filter可以放在 if 后面做条件。</p>
<h6 id="4_2">4. 模板的继承</h6>
<p>tpl.html 继承 layout.html，</p>
<p><kbd>tpl.html</kbd>：</p>
<pre><code class="py">{% extends 'layout.html' %}
{% block content %}
    {% if 1|test(2,3) %}
        &lt;div&gt;True&lt;/div&gt;
    {% else %}
        &lt;div&gt;False&lt;/div&gt;
    {% endif %}
{% endblock %}
</code></pre>

<p><kbd>layout.html</kbd>：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h4&gt;继承&lt;/h4&gt;
{% block content %}{% endblock %}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h6 id="5_3">5. 模板的包含</h6>
<p><kbd>tpl.html</kbd>：</p>
<pre><code class="html">{% include 'form.html' %}
</code></pre>

<p><kbd>form.html</kbd>：</p>
<pre><code class="html">&lt;form action=&quot;&quot;&gt;
    form表单
&lt;/form&gt;
</code></pre>

<h6 id="6_2">6. 宏定义的使用</h6>
<p><kbd>tpl.html</kbd>：</p>
<pre><code class="html">{#默认是不显示的#}
{% macro input(name,type='text',value='') %}
    &lt;input type=&quot;{{ type }}&quot; name=&quot;{{ name }}&quot; value=&quot;{{ value }}&quot;&gt;
{% endmacro %}
{#如果想显示#}
{{ input('username') }}
</code></pre>

<h6 id="7">7. 模板安全</h6>
<p>前端：<kbd>{{u|safe}}</kbd></p>
<p>后端：<kbd>Markup("<input type="text"/ >")</kbd>
<hr></p></div>
        </div>

        <footer class="col-md-12">
<!--    <hr>-->
    
    <p>Copyright © 2020-2022 bysj39.com All Rights Reserved.</p>
    <p><a href="https://beian.miit.gov.cn" target="_blank">豫ICP备19037971号-1</a><a target="_blank">
                <img src="http://47.102.145.225:5000/static/home/images/beian.png" style="padding-bottom:6px">
                <span style="color: black">豫公网安备 41152802000091号</span>
            </a></p>
    <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>

        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../js/main.js" defer></script>
        <script src="../js/busuanzi.pure.mini.js" defer></script>
        <script src="../js/gotop.js" defer></script>

        <div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
